{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to FlowerPower-MQTT Documentation","text":"<p>A simple yet powerful MQTT plugin for FlowerPower that triggers pipeline execution when messages arrive on subscribed topics. <code>flowerpower-mqtt</code> features configurable QoS levels, optional RQ job queue integration for asynchronous processing, and a beautiful CLI for easy management.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Simple API: Easy-to-use interface for connecting, subscribing, and listening.</li> <li>QoS Support: Full MQTT QoS support (0, 1, 2) for reliable message delivery.</li> <li>Async Processing: Optional RQ job queue integration for background pipeline execution.</li> <li>Multiple Execution Modes: <code>sync</code>, <code>async</code>, and <code>mixed</code> (QoS-based routing).</li> <li>Topic Wildcards: Support for MQTT topic patterns (<code>+</code>, <code>#</code>).</li> <li>Graceful Shutdown: Ctrl+C handling and proper cleanup.</li> <li>Statistics &amp; Monitoring: Built-in metrics and job tracking.</li> <li>Configuration Management: YAML-based configuration support with <code>msgspec</code> validation.</li> <li>Automatic Reconnection: Robust connection handling with configurable retry attempts and exponential backoff.</li> <li>Comprehensive CLI: Rich, colorful CLI with interactive configuration, real-time monitoring, and job queue management.</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>The <code>flowerpower-mqtt</code> library is designed with modularity in mind, allowing for flexible integration and robust operation. The core components interact to provide seamless MQTT message processing and FlowerPower pipeline execution.</p> <pre><code>graph TD\n    subgraph User Interaction\n        A[Programmatic API: MQTTPlugin]\n        B[CLI: flowerpower-mqtt]\n    end\n\n    subgraph Core Library\n        C[MQTTListener]\n        D[MQTTClient]\n        E[Configuration]\n        F[Job Handler]\n    end\n\n    subgraph External Systems\n        G[MQTT Broker]\n        H[FlowerPower Pipelines]\n        I[Redis / RQ]\n    end\n\n    A -- Manages --&gt; C\n    B -- Controls --&gt; C\n    C -- Uses --&gt; D\n    C -- Uses --&gt; F\n    D -- Communicates with --&gt; G\n    F -- Executes --&gt; H\n    F -- Uses --&gt; I\n\n    E -- Configures --&gt; C\n    E -- Configures --&gt; D\n    E -- Configures --&gt; F\n\n    style A fill:#cde4ff\n    style B fill:#cde4ff\n    style G fill:#ffefc1\n    style H fill:#ffefc1\n    style I fill:#ffefc1</code></pre> <ul> <li>User Interaction: Users can interact with the library either programmatically through the <code>MQTTPlugin</code> API or via the command-line interface (<code>flowerpower-mqtt</code> CLI).</li> <li>Core Library:<ul> <li><code>MQTTListener</code>: The central component responsible for listening to MQTT messages and coordinating their processing.</li> <li><code>MQTTClient</code>: Handles the low-level MQTT connection, subscription, and message reception.</li> <li><code>Configuration</code>: Manages the application's settings, including MQTT broker details, job queue settings, and subscriptions.</li> <li><code>Job Handler</code>: Integrates with the RQ job queue for asynchronous pipeline execution.</li> </ul> </li> <li>External Systems:<ul> <li><code>MQTT Broker</code>: The external MQTT server that <code>flowerpower-mqtt</code> connects to.</li> <li><code>FlowerPower Pipelines</code>: The actual data processing workflows triggered by MQTT messages.</li> <li><code>Redis / RQ</code>: Used for managing the asynchronous job queue.</li> </ul> </li> </ul>"},{"location":"#who-is-this-for","title":"Who is this for?","text":"<p>This documentation is for:</p> <ul> <li>FlowerPower Users: If you are already using FlowerPower and want to integrate MQTT-based data sources into your pipelines.</li> <li>Developers: If you are building applications that need to react to MQTT messages by executing Python-based data pipelines.</li> <li>System Administrators: If you need to deploy, monitor, and manage MQTT-driven data processing workflows.</li> </ul>"},{"location":"#relationship-with-flowerpower","title":"Relationship with FlowerPower","text":"<p><code>flowerpower-mqtt</code> acts as a specialized plugin for the <code>flowerpower</code> library, extending its capabilities to include MQTT message processing. It leverages FlowerPower's pipeline execution engine to process incoming MQTT data, making it easy to integrate real-time MQTT streams into your existing data workflows.</p>"},{"location":"advanced-topics/","title":"Advanced Topics","text":"<p>This section covers more advanced aspects of <code>flowerpower-mqtt</code>, including error handling, graceful shutdown procedures, context manager usage, and automatic reconnection mechanisms.</p>"},{"location":"advanced-topics/#error-handling","title":"Error Handling","text":"<p><code>flowerpower-mqtt</code> is designed with robust error handling to provide informative feedback when issues arise. The library defines a hierarchy of custom exceptions, all inheriting from <code>FlowerPowerMQTTError</code>.</p> <ul> <li><code>FlowerPowerMQTTError</code>: Base exception for all <code>flowerpower-mqtt</code> errors.</li> <li><code>ConnectionError</code>: Raised when there are issues connecting to or disconnecting from the MQTT broker.</li> <li><code>SubscriptionError</code>: Raised when there are problems with subscribing to or unsubscribing from MQTT topics (e.g., invalid QoS level).</li> <li><code>ConfigurationError</code>: Raised when there are issues with the <code>flowerpower-mqtt</code> configuration (e.g., invalid settings, missing required fields).</li> <li><code>PipelineExecutionError</code>: Raised when a FlowerPower pipeline fails during execution.</li> <li><code>JobQueueError</code>: Raised when there are issues related to the job queue (e.g., failed initialization).</li> </ul> <p>You should wrap your <code>flowerpower-mqtt</code> operations in <code>try-except</code> blocks to gracefully handle these exceptions.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin, ConnectionError, SubscriptionError, ConfigurationError\n\nasync def main():\n    try:\n        # Example: Connection error\n        mqtt_bad_broker = MQTTPlugin(broker=\"nonexistent.broker.com\", base_dir=\".\")\n        await mqtt_bad_broker.connect()\n    except ConnectionError as e:\n        print(f\"Caught ConnectionError: {e}\")\n    except Exception as e:\n        print(f\"Caught unexpected error: {type(e).__name__}: {e}\")\n\n    try:\n        # Example: Subscription error (invalid QoS)\n        mqtt_valid = MQTTPlugin(broker=\"localhost\", base_dir=\".\")\n        await mqtt_valid.connect()\n        await mqtt_valid.subscribe(\"test/topic\", \"my_pipeline\", qos=5) # Invalid QoS\n    except SubscriptionError as e:\n        print(f\"Caught SubscriptionError: {e}\")\n    except Exception as e:\n        print(f\"Caught unexpected error: {type(e).__name__}: {e}\")\n    finally:\n        if mqtt_valid.is_connected:\n            await mqtt_valid.disconnect()\n\n    try:\n        # Example: Configuration error (e.g., missing base_dir if not provided in config)\n        # This would typically happen during MQTTPlugin initialization if config is invalid\n        pass # Configuration errors are usually caught during from_config or __init__\n    except ConfigurationError as e:\n        print(f\"Caught ConfigurationError: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"advanced-topics/#logging-errors","title":"Logging Errors","text":"<p>In addition to raising exceptions, <code>flowerpower-mqtt</code> extensively uses Python's standard <code>logging</code> module to report events and errors. You can configure the logging level in your <code>mkdocs.yml</code> file (<code>log_level</code> parameter) or programmatically.</p> <p>It's recommended to configure your application's logging to capture <code>ERROR</code> and <code>WARNING</code> level messages from <code>flowerpower_mqtt</code> for effective troubleshooting.</p>"},{"location":"advanced-topics/#graceful-shutdown","title":"Graceful Shutdown","text":"<p><code>flowerpower-mqtt</code> is designed to shut down gracefully, ensuring that all pending operations are completed and resources are released cleanly.</p> <p>When the listener is running (via <code>mqtt.start_listener()</code>), it listens for <code>Ctrl+C</code> (KeyboardInterrupt) signals. Upon receiving such a signal, it initiates a graceful shutdown sequence:</p> <ol> <li>Logs an informational message about the shutdown.</li> <li>Attempts to stop the internal message listener task.</li> <li>Disconnects from the MQTT broker, which also cleans up any active subscriptions.</li> </ol> <p>You can also explicitly stop the listener programmatically using <code>stop_listener()</code>.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    mqtt = MQTTPlugin(broker=\"localhost\", base_dir=\".\")\n    await mqtt.connect()\n    await mqtt.subscribe(\"test/topic\", \"test_pipeline\")\n\n    # Start listener in background\n    listener_task = asyncio.create_task(mqtt.start_listener(background=True))\n\n    print(\"Listener started in background. Running for 5 seconds...\")\n    await asyncio.sleep(5)\n\n    print(\"Stopping listener gracefully...\")\n    await mqtt.stop_listener()\n\n    # Wait for the background task to finish (optional but good practice)\n    await listener_task\n\n    print(\"Listener stopped and resources released.\")\n    await mqtt.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"advanced-topics/#context-manager-usage","title":"Context Manager Usage","text":"<p>For robust resource management, especially in asynchronous applications, it is highly recommended to use <code>MQTTPlugin</code> as an asynchronous context manager (<code>async with</code>).</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def run_my_app():\n    async with MQTTPlugin(broker=\"localhost\", base_dir=\".\") as mqtt:\n        # Connection is automatically established when entering the 'async with' block\n        print(\"Connected to MQTT broker.\")\n\n        await mqtt.subscribe(\"data/sensors\", \"process_sensor_data\")\n        print(\"Subscribed to 'data/sensors'.\")\n\n        print(\"Starting listener...\")\n        await mqtt.start_listener()\n\n        # When the 'async with' block exits (either normally or due to an exception),\n        # the 'mqtt.disconnect()' method is automatically called, ensuring\n        # a clean shutdown and resource release.\n\n    print(\"Disconnected from MQTT broker.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(run_my_app())\n</code></pre> <p>Using the context manager ensures that <code>connect()</code> is called upon entry and <code>disconnect()</code> is called upon exit, even if exceptions occur within the block.</p>"},{"location":"advanced-topics/#automatic-reconnection","title":"Automatic Reconnection","text":"<p>The <code>MQTTClient</code> (used internally by <code>MQTTPlugin</code>) is designed to handle temporary disconnections from the MQTT broker automatically. It implements a reconnection strategy with configurable retries and exponential backoff.</p> <ul> <li><code>reconnect_retries</code>: The maximum number of times <code>flowerpower-mqtt</code> will attempt to reconnect to the broker after a disconnection.</li> <li><code>reconnect_delay</code>: The base delay in seconds used for exponential backoff between reconnection attempts. The delay increases with each failed attempt (e.g., <code>delay * (2 ** attempt)</code>).</li> </ul> <p>These parameters can be configured in your <code>mqtt</code> configuration section:</p> <pre><code>mqtt:\n  broker: \"mqtt.example.com\"\n  reconnect_retries: 10 # Try to reconnect 10 times\n  reconnect_delay: 5   # Start with 5 seconds delay, then 10s, 20s, etc.\n</code></pre> <p>During reconnection attempts, <code>flowerpower-mqtt</code> will log warnings and informational messages. If all reconnection attempts fail, a <code>ConnectionError</code> will be raised.</p>"},{"location":"async-processing/","title":"Asynchronous Processing","text":"<p><code>flowerpower-mqtt</code> can offload the execution of FlowerPower pipelines to a job queue, enabling asynchronous processing. This is particularly useful for long-running or computationally intensive pipelines, ensuring that the MQTT listener remains responsive and can handle high message throughput.</p>"},{"location":"async-processing/#when-to-use-asynchronous-processing","title":"When to Use Asynchronous Processing","text":"<p>Consider using asynchronous processing with a job queue in the following scenarios:</p> <ul> <li>Long-running Pipelines: If your FlowerPower pipelines take a significant amount of time to execute (e.g., several seconds to minutes), running them synchronously would block the MQTT listener, potentially causing message backlogs or disconnections.</li> <li>High Message Throughput: For applications receiving a large volume of MQTT messages, asynchronous processing allows the system to quickly acknowledge messages and queue pipeline executions without being bottlenecked by the processing time of individual pipelines.</li> <li>Decoupling: Separating the message reception and pipeline execution logic provides better system decoupling, making it more resilient and scalable.</li> <li>Distributed Processing: A job queue allows you to distribute pipeline execution across multiple worker processes or even different machines, horizontally scaling your processing capabilities.</li> <li>Reliability and Retries: Job queues often provide built-in mechanisms for retrying failed jobs, improving the overall reliability of your pipeline executions.</li> </ul>"},{"location":"async-processing/#configuration","title":"Configuration","text":"<p>To enable asynchronous processing, you need to configure the <code>job_queue</code> section in your <code>flowerpower-mqtt</code> configuration.</p> <pre><code># mqtt_config.yml\njob_queue:\n  enabled: true\n  type: \"rq\" # Currently only \"rq\" is supported\n  redis_url: \"redis://localhost:6379\" # Your Redis connection URL\n  queue_name: \"mqtt_pipelines\" # Name of the RQ queue\n  worker_count: 4 # Recommended number of RQ workers\n  max_retries: 3 # Max retries for failed jobs\n</code></pre> <ul> <li><code>enabled</code> (<code>bool</code>): Set to <code>true</code> to activate the job queue.</li> <li><code>type</code> (<code>str</code>): Specifies the type of job queue. Currently, only <code>\"rq\"</code> (RQ - Redis Queue) is supported.</li> <li><code>redis_url</code> (<code>str</code>): The connection URL for your Redis server. Redis is required by RQ to store job data and manage queues.</li> <li><code>queue_name</code> (<code>str</code>): The name of the RQ queue that <code>flowerpower-mqtt</code> will enqueue jobs into. Your RQ workers must listen to this same queue name.</li> <li><code>worker_count</code> (<code>int</code>): This is a recommended value for the number of RQ workers you might want to run. It does not automatically start workers.</li> <li><code>max_retries</code> (<code>int</code>): The maximum number of times a failed job will be retried by RQ.</li> </ul>"},{"location":"async-processing/#rq-worker","title":"RQ Worker","text":"<p>While <code>flowerpower-mqtt</code> enqueues jobs, it does not execute them. You need to run separate RQ worker processes that listen to the configured queue and execute the enqueued FlowerPower pipelines.</p>"},{"location":"async-processing/#starting-an-rq-worker","title":"Starting an RQ Worker","text":"<p>You can start an RQ worker from your terminal. Ensure you have <code>rq</code> installed (<code>pip install rq</code>) and that your Redis server is running.</p> <pre><code># In a separate terminal, from your project's root directory\nrq worker mqtt_pipelines --url redis://localhost:6379\n</code></pre> <ul> <li>Replace <code>mqtt_pipelines</code> with the <code>queue_name</code> specified in your <code>flowerpower-mqtt</code> configuration.</li> <li>Replace <code>redis://localhost:6379</code> with your <code>redis_url</code>.</li> </ul> <p>You can run multiple RQ workers to process jobs concurrently. Each worker will pick up jobs from the queue as they become available.</p>"},{"location":"async-processing/#managing-workers-via-cli","title":"Managing Workers via CLI","text":"<p>The <code>flowerpower-mqtt</code> CLI provides convenience commands for managing RQ workers:</p> <ul> <li><code>flowerpower-mqtt jobs worker status</code>: Checks if RQ workers are running for the configured queue.</li> <li><code>flowerpower-mqtt jobs worker start --count N</code>: Provides the command to manually start <code>N</code> RQ workers.</li> <li><code>flowerpower-mqtt jobs worker stop</code>: Attempts to stop running RQ worker processes.</li> </ul>"},{"location":"async-processing/#job-lifecycle","title":"Job Lifecycle","text":"<ol> <li>Message Reception: <code>flowerpower-mqtt</code> receives an MQTT message on a subscribed topic.</li> <li>Execution Mode Check: If the subscription's <code>execution_mode</code> is <code>\"async\"</code> or <code>\"mixed\"</code> (and QoS is 0/1), the pipeline execution is prepared as a job.</li> <li>Job Enqueueing: The job is enqueued into the configured RQ queue (e.g., <code>mqtt_pipelines</code>) in Redis.</li> <li>Worker Processing: An available RQ worker picks up the job from the queue.</li> <li>Pipeline Execution: The worker executes the specified FlowerPower pipeline, passing the MQTT message data as input.</li> <li>Job Completion/Failure:<ul> <li>If the pipeline completes successfully, the job is marked as finished.</li> <li>If the pipeline fails, the job is marked as failed, and RQ may retry it based on the <code>max_retries</code> setting.</li> </ul> </li> </ol>"},{"location":"async-processing/#monitoring-jobs","title":"Monitoring Jobs","text":"<p>You can monitor the status of enqueued and executed jobs using both the CLI and programmatic methods.</p>"},{"location":"async-processing/#cli-monitoring","title":"CLI Monitoring","text":"<p>Use the <code>flowerpower-mqtt jobs status</code> command to get an overview of the job queue:</p> <pre><code>flowerpower-mqtt jobs status\n</code></pre> <p>This command provides information about whether the job queue is enabled and details about the queue name and type.</p>"},{"location":"async-processing/#programmatic-monitoring","title":"Programmatic Monitoring","text":"<p>The <code>MQTTPlugin.get_statistics()</code> method includes information about the job queue if it's enabled.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    mqtt = MQTTPlugin.from_config(\"mqtt_config.yml\")\n    await mqtt.connect()\n\n    stats = mqtt.get_statistics()\n    if stats.get(\"job_queue_enabled\"):\n        print(f\"Job Queue Name: {stats['job_queue_stats']['queue_name']}\")\n        print(f\"Job Queue Type: {stats['job_queue_stats']['type']}\")\n        # Additional RQ-specific monitoring would require direct RQ API interaction\n\n    await mqtt.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>For more detailed job monitoring (e.g., viewing individual job statuses, retries, or worker health), you would typically use RQ's built-in tools like <code>rqinfo</code> or integrate with a monitoring dashboard that supports RQ.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This document tracks significant changes and new features in <code>flowerpower-mqtt</code>.</p>"},{"location":"changelog/#v020-current","title":"v0.2.0 (Current)","text":"<ul> <li>Breaking Change: Migrated from Pydantic to <code>msgspec.Struct</code> for 10-50x performance improvement in configuration handling.</li> <li>New: Comprehensive CLI with beautiful <code>rich</code> output.</li> <li>New: Interactive configuration creation and management via CLI.</li> <li>New: Real-time monitoring with <code>rich</code> tables and charts.</li> <li>New: Job queue management commands via CLI.</li> <li>New: Shell completion support for CLI commands.</li> <li>New: JSON output option for CLI commands, enabling easier scripting and automation.</li> <li>Enhanced: Configuration validation with detailed error messages.</li> <li>Enhanced: Better error handling throughout the codebase.</li> </ul>"},{"location":"changelog/#v010","title":"v0.1.0","text":"<ul> <li>Initial release.</li> <li>Basic MQTT subscription and FlowerPower pipeline execution.</li> <li>QoS support (0, 1, 2) for MQTT messages.</li> <li>RQ job queue integration for asynchronous processing.</li> <li>Basic configuration management.</li> <li>Graceful shutdown handling.</li> <li>Initial statistics and monitoring capabilities.</li> </ul>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>The <code>flowerpower-mqtt</code> Command Line Interface (CLI) provides a comprehensive set of commands for managing MQTT connections, subscriptions, and monitoring, all with rich and interactive output.</p>"},{"location":"cli-reference/#global-options","title":"Global Options","text":"<p>These options can be used with most <code>flowerpower-mqtt</code> commands:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>, optional): Specify a configuration file to use.</li> <li><code>--json</code> (<code>bool</code>): Output results in JSON format, useful for scripting and automation.</li> </ul>"},{"location":"cli-reference/#commands","title":"Commands","text":""},{"location":"cli-reference/#flowerpower-mqtt-connect","title":"<code>flowerpower-mqtt connect</code>","text":"<p>Connects to an MQTT broker.</p> <pre><code>flowerpower-mqtt connect [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--broker</code>, <code>-b</code> (<code>str</code>): MQTT broker hostname (default: <code>localhost</code>).</li> <li><code>--port</code>, <code>-p</code> (<code>int</code>): MQTT broker port (default: <code>1883</code>).</li> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--base-dir</code> (<code>str</code>): FlowerPower project directory (default: <code>.</code>).</li> <li><code>--job-queue</code> (<code>bool</code>): Enable RQ job queue.</li> <li><code>--redis-url</code> (<code>str</code>): Redis URL for job queue (default: <code>redis://localhost:6379</code>).</li> <li><code>--save-config</code> (<code>bool</code>): Save the current connection configuration to a file.</li> </ul> <p>Examples:</p> <pre><code># Connect to a broker on default port\nflowerpower-mqtt connect --broker mqtt.example.com\n\n# Connect with job queue enabled\nflowerpower-mqtt connect --broker mqtt.example.com --job-queue --redis-url redis://my-redis:6379\n\n# Connect using a configuration file\nflowerpower-mqtt connect --config my_mqtt_config.yml\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-disconnect","title":"<code>flowerpower-mqtt disconnect</code>","text":"<p>Disconnects from the currently connected MQTT broker.</p> <pre><code>flowerpower-mqtt disconnect [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt disconnect\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-subscribe","title":"<code>flowerpower-mqtt subscribe</code>","text":"<p>Subscribes to an MQTT topic and links it to a FlowerPower pipeline.</p> <pre><code>flowerpower-mqtt subscribe TOPIC PIPELINE_NAME [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>TOPIC</code> (<code>str</code>): MQTT topic pattern to subscribe to.</li> <li><code>PIPELINE_NAME</code> (<code>str</code>): Name of the FlowerPower pipeline to execute.</li> </ul> <p>Options:</p> <ul> <li><code>--qos</code>, <code>-q</code> (<code>int</code>): QoS level (0, 1, or 2) (default: <code>0</code>).</li> <li><code>--mode</code>, <code>-m</code> (<code>str</code>): Execution mode (<code>sync</code>, <code>async</code>, or <code>mixed</code>) (default: <code>sync</code>).</li> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--save-config</code> (<code>bool</code>): Save the new subscription to the configuration file.</li> </ul> <p>Examples:</p> <pre><code># Subscribe to a topic with default settings\nflowerpower-mqtt subscribe \"sensors/temp\" process_temp_data\n\n# Subscribe with QoS 1 and async execution\nflowerpower-mqtt subscribe \"logs/system\" analyze_logs --qos 1 --mode async\n\n# Subscribe with mixed execution mode\nflowerpower-mqtt subscribe \"events/#\" handle_event --qos 2 --mode mixed\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-unsubscribe","title":"<code>flowerpower-mqtt unsubscribe</code>","text":"<p>Unsubscribes from a previously subscribed MQTT topic.</p> <pre><code>flowerpower-mqtt unsubscribe TOPIC [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>TOPIC</code> (<code>str</code>): The exact MQTT topic pattern to unsubscribe from.</li> </ul> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--save-config</code> (<code>bool</code>): Save changes to the configuration file.</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt unsubscribe \"sensors/temp\"\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-listen","title":"<code>flowerpower-mqtt listen</code>","text":"<p>Starts listening for incoming MQTT messages and triggers pipeline execution.</p> <pre><code>flowerpower-mqtt listen [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--background</code>, <code>-bg</code> (<code>bool</code>): Run the listener in the background.</li> <li><code>--override-mode</code> (<code>str</code>): Override the execution mode for all pipelines (<code>sync</code>, <code>async</code>, or <code>mixed</code>).</li> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--timeout</code> (<code>int</code>): Stop listening after a specified number of seconds.</li> </ul> <p>Examples:</p> <pre><code># Start listening indefinitely (blocks terminal)\nflowerpower-mqtt listen\n\n# Start listening in the background\nflowerpower-mqtt listen --background &amp;\n\n# Override all subscriptions to use async execution\nflowerpower-mqtt listen --override-mode async --config my_config.yml\n\n# Listen for 60 seconds\nflowerpower-mqtt listen --timeout 60\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-status","title":"<code>flowerpower-mqtt status</code>","text":"<p>Shows the current plugin status and statistics.</p> <pre><code>flowerpower-mqtt status [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--json</code> (<code>bool</code>): Output status as JSON.</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt status\nflowerpower-mqtt status --json\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-monitor","title":"<code>flowerpower-mqtt monitor</code>","text":"<p>Monitors the MQTT plugin in real-time, displaying live statistics and subscription activity.</p> <pre><code>flowerpower-mqtt monitor [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--interval</code>, <code>-i</code> (<code>int</code>): Update interval in seconds (default: <code>5</code>).</li> <li><code>--duration</code>, <code>-d</code> (<code>int</code>): Monitor duration in seconds.</li> <li><code>--json</code> (<code>bool</code>): Output monitoring data as JSON.</li> </ul> <p>Examples:</p> <pre><code># Monitor every 5 seconds indefinitely\nflowerpower-mqtt monitor\n\n# Monitor for 300 seconds (5 minutes)\nflowerpower-mqtt monitor --duration 300\n\n# Output real-time data as JSON\nflowerpower-mqtt monitor --json\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-list-subscriptions","title":"<code>flowerpower-mqtt list-subscriptions</code>","text":"<p>Lists all active MQTT subscriptions.</p> <pre><code>flowerpower-mqtt list-subscriptions [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--active</code> (<code>bool</code>): Show only subscriptions with messages received.</li> <li><code>--json</code> (<code>bool</code>): Output subscriptions as JSON.</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt list-subscriptions\nflowerpower-mqtt list-subscriptions --active\nflowerpower-mqtt list-subscriptions --json\n</code></pre>"},{"location":"cli-reference/#configuration-commands-flowerpower-mqtt-config","title":"Configuration Commands (<code>flowerpower-mqtt config</code>)","text":"<p>A sub-command group for managing configuration files.</p>"},{"location":"cli-reference/#flowerpower-mqtt-config-create","title":"<code>flowerpower-mqtt config create</code>","text":"<p>Creates a new configuration file.</p> <pre><code>flowerpower-mqtt config create [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--output</code>, <code>-o</code> (<code>Path</code>): Output file path (default: <code>mqtt_config.yml</code>).</li> <li><code>--interactive</code>, <code>-i</code> (<code>bool</code>): Start an interactive configuration wizard.</li> <li><code>--job-queue</code> (<code>bool</code>): Include job queue configuration in the new file.</li> </ul> <p>Examples:</p> <pre><code># Create a default config file\nflowerpower-mqtt config create\n\n# Create interactively\nflowerpower-mqtt config create --interactive\n\n# Create with job queue enabled and custom output path\nflowerpower-mqtt config create --job-queue --output production_config.yml\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-config-validate","title":"<code>flowerpower-mqtt config validate</code>","text":"<p>Validates an existing configuration file.</p> <pre><code>flowerpower-mqtt config validate CONFIG_FILE\n</code></pre> <p>Arguments:</p> <ul> <li><code>CONFIG_FILE</code> (<code>Path</code>): Path to the configuration file to validate.</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt config validate my_mqtt_config.yml\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-config-show","title":"<code>flowerpower-mqtt config show</code>","text":"<p>Displays the content of a configuration file.</p> <pre><code>flowerpower-mqtt config show [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to show.</li> <li><code>--format</code> (<code>str</code>): Output format (<code>yaml</code> or <code>json</code>) (default: <code>yaml</code>).</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt config show\nflowerpower-mqtt config show --config production_config.yml --format json\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-config-edit","title":"<code>flowerpower-mqtt config edit</code>","text":"<p>Opens a configuration file in your default editor (<code>$EDITOR</code>).</p> <pre><code>flowerpower-mqtt config edit [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to edit.</li> <li><code>--editor</code> (<code>str</code>): Specify a different editor to use.</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt config edit\nflowerpower-mqtt config edit --editor nano my_mqtt_config.yml\n</code></pre>"},{"location":"cli-reference/#job-queue-commands-flowerpower-mqtt-jobs","title":"Job Queue Commands (<code>flowerpower-mqtt jobs</code>)","text":"<p>A sub-command group for managing RQ job queues.</p>"},{"location":"cli-reference/#flowerpower-mqtt-jobs-status","title":"<code>flowerpower-mqtt jobs status</code>","text":"<p>Shows the status of the job queue.</p> <pre><code>flowerpower-mqtt jobs status [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> <li><code>--json</code> (<code>bool</code>): Output status as JSON.</li> </ul> <p>Examples:</p> <pre><code>flowerpower-mqtt jobs status\nflowerpower-mqtt jobs status --json\n</code></pre>"},{"location":"cli-reference/#flowerpower-mqtt-jobs-worker","title":"<code>flowerpower-mqtt jobs worker</code>","text":"<p>Manages RQ workers (start, stop, status).</p> <pre><code>flowerpower-mqtt jobs worker ACTION [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>ACTION</code> (<code>str</code>): Worker action (<code>start</code>, <code>stop</code>, or <code>status</code>).</li> </ul> <p>Options:</p> <ul> <li><code>--count</code>, <code>-c</code> (<code>int</code>): Number of workers to start (default: <code>1</code>).</li> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Configuration file to use.</li> </ul> <p>Examples:</p> <pre><code># Get status of running workers\nflowerpower-mqtt jobs worker status\n\n# Start 2 RQ workers (note: this command only prints the command to run manually)\nflowerpower-mqtt jobs worker start --count 2\n\n# Stop running workers\nflowerpower-mqtt jobs worker stop\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to <code>flowerpower-mqtt</code>! Whether it's reporting a bug, suggesting a new feature, improving the documentation, or submitting code, your help is greatly appreciated.</p> <p>Please take a moment to review this guide before making your first contribution.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the Repository: Start by forking the <code>flowerpower-mqtt</code> repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.     <pre><code>git clone https://github.com/YOUR_USERNAME/flowerpower-mqtt.git\ncd flowerpower-mqtt\n</code></pre></li> <li>Install Development Dependencies: Set up your development environment by installing the necessary dependencies.     <pre><code>uv pip install -e \".[dev]\"\n</code></pre></li> <li>Create a Feature Branch: Create a new branch for your feature or bug fix. Use a descriptive name (e.g., <code>feature/add-new-cli-command</code>, <code>bugfix/fix-connection-error</code>).     <pre><code>git checkout -b feature/your-feature-name\n</code></pre></li> <li>Make Your Changes: Implement your feature or bug fix.<ul> <li>Adhere to the existing code style.</li> <li>Write clear, concise, and well-documented code.</li> </ul> </li> <li>Add Tests: Ensure your changes are covered by tests. If you're adding a new feature, write new tests for it. If you're fixing a bug, add a test that reproduces the bug and then passes with your fix.</li> <li>Run the Test Suite: Before submitting your changes, run the entire test suite to ensure nothing is broken.     <pre><code>pytest\n</code></pre></li> <li>Type Checking: Ensure your code passes type checks.     <pre><code>mypy src/\n</code></pre></li> <li>Code Formatting and Linting: Format your code and check for linting issues.     <pre><code>black src/\nruff check src/\n</code></pre></li> <li>Commit Your Changes: Commit your changes with a clear and descriptive commit message. Follow conventional commit guidelines if possible.     <pre><code>git commit -m \"feat: Add new awesome feature\"\n</code></pre></li> <li>Push to Your Fork: Push your changes to your fork on GitHub.     <pre><code>git push origin feature/your-feature-name\n</code></pre></li> <li>Submit a Pull Request: Open a pull request from your feature branch to the <code>main</code> branch of the original <code>flowerpower-mqtt</code> repository.<ul> <li>Provide a clear title and description for your pull request.</li> <li>Reference any related issues.</li> <li>Be responsive to feedback from maintainers.</li> </ul> </li> </ol>"},{"location":"contributing/#code-style-and-quality","title":"Code Style and Quality","text":"<p>We use <code>black</code> for code formatting, <code>ruff</code> for linting, and <code>mypy</code> for type checking. Please ensure your contributions adhere to these standards.</p>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug, please open an issue on the GitHub issue tracker. When reporting a bug, please include:</p> <ul> <li>A clear and concise description of the bug.</li> <li>Steps to reproduce the behavior.</li> <li>Expected behavior.</li> <li>Actual behavior.</li> <li>Any relevant error messages or stack traces.</li> <li>Your operating system, Python version, and <code>flowerpower-mqtt</code> version.</li> </ul>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>We'd love to hear your ideas for new features! Please open an issue on the GitHub issue tracker to propose new features. Describe the problem you're trying to solve and how the new feature would help.</p>"},{"location":"contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>High-quality documentation is crucial. If you find errors, omissions, or areas that could be improved, please open an issue or submit a pull request with your changes.</p> <p>Thank you for contributing to <code>flowerpower-mqtt</code>!</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>Understanding the core concepts of <code>flowerpower-mqtt</code> is essential for effectively using and integrating the library into your projects.</p>"},{"location":"core-concepts/#the-mqttplugin","title":"The <code>MQTTPlugin</code>","text":"<p>The <code>MQTTPlugin</code> class is the central interface for programmatic interaction with <code>flowerpower-mqtt</code>. It encapsulates the MQTT client, listener, and configuration management, providing a high-level API for connecting to brokers, managing subscriptions, and controlling message processing.</p> <p>You'll typically instantiate <code>MQTTPlugin</code> either directly with connection parameters or by loading a configuration from a YAML file.</p> <pre><code>from flowerpower_mqtt import MQTTPlugin\n\n# Instantiate directly\nmqtt_direct = MQTTPlugin(broker=\"localhost\", base_dir=\"./my_flowerpower_project\")\n\n# Instantiate from a configuration file\nmqtt_from_config = MQTTPlugin.from_config(\"mqtt_config.yml\")\n</code></pre>"},{"location":"core-concepts/#execution-modes","title":"Execution Modes","text":"<p><code>flowerpower-mqtt</code> offers flexible execution modes to handle incoming MQTT messages and trigger FlowerPower pipelines. These modes determine how the pipeline execution is managed, especially concerning synchronous vs. asynchronous processing.</p>"},{"location":"core-concepts/#sync-synchronous","title":"<code>sync</code> (Synchronous)","text":"<ul> <li>Description: In <code>sync</code> mode, when an MQTT message is received, the associated FlowerPower pipeline is executed directly within the main event loop. This means the message processing is blocking; the listener will wait for the pipeline to complete before processing the next message.</li> <li>Use Cases:<ul> <li>Pipelines that are very fast and do not require significant computation time.</li> <li>Scenarios where immediate feedback or sequential processing is critical.</li> <li>Simple setups where an external job queue is not desired or available.</li> </ul> </li> <li>Considerations: Can lead to message backlog if pipelines take too long to execute, potentially impacting MQTT message processing latency.</li> </ul>"},{"location":"core-concepts/#async-asynchronous","title":"<code>async</code> (Asynchronous)","text":"<ul> <li>Description: In <code>async</code> mode, when an MQTT message is received, the associated FlowerPower pipeline is enqueued as a job into an external job queue (currently RQ). The main event loop continues to process incoming messages without waiting for the pipeline to complete. A separate worker process (or processes) then picks up and executes these jobs in the background.</li> <li>Use Cases:<ul> <li>Long-running or computationally intensive pipelines.</li> <li>Scenarios requiring high message throughput without blocking the MQTT listener.</li> <li>Distributed processing where multiple workers can handle jobs concurrently.</li> <li>When you need robust retry mechanisms and persistent job queues.</li> </ul> </li> <li>Considerations: Requires a running Redis instance and RQ workers. Adds complexity due to distributed processing.</li> </ul>"},{"location":"core-concepts/#mixed-qos-based-routing","title":"<code>mixed</code> (QoS-based Routing)","text":"<ul> <li>Description: <code>mixed</code> mode provides a dynamic approach to execution by routing messages based on their MQTT Quality of Service (QoS) level.<ul> <li>Messages with QoS 2 (Exactly-once delivery) are executed synchronously. This is because QoS 2 messages require a more robust acknowledgment handshake, and synchronous processing ensures the pipeline completes before the MQTT broker is fully acknowledged.</li> <li>Messages with QoS 0 (At most once) or QoS 1 (At least once) are executed asynchronously via the job queue.</li> </ul> </li> <li>Use Cases:<ul> <li>Environments with a mix of critical and non-critical data streams.</li> <li>When you want to prioritize the reliability of certain messages while maintaining high throughput for others.</li> </ul> </li> <li>Considerations: Requires careful consideration of your MQTT QoS strategy and a properly configured job queue.</li> </ul>"},{"location":"core-concepts/#configuration","title":"Configuration","text":"<p><code>flowerpower-mqtt</code> uses a flexible YAML-based configuration system. This allows you to define MQTT connection parameters, job queue settings, and all your topic subscriptions in a human-readable file.</p> <p>A typical configuration file (<code>mqtt_config.yml</code>) looks like this:</p> <pre><code>mqtt:\n  broker: \"mqtt.example.com\"\n  port: 1883\n  keepalive: 60\n  client_id: \"flowerpower_mqtt_client\"\n  reconnect_retries: 5\n  reconnect_delay: 5\n\nsubscriptions:\n  - topic: \"sensors/+/temperature\"\n    pipeline: \"temperature_processor\"\n    qos: 1\n    execution_mode: \"async\"\n  - topic: \"alerts/critical\"\n    pipeline: \"alert_handler\"\n    qos: 2\n    execution_mode: \"sync\"\n\njob_queue:\n  enabled: true\n  type: \"rq\"\n  redis_url: \"redis://localhost:6379\"\n  queue_name: \"mqtt_pipelines\"\n  worker_count: 4\n\nbase_dir: \"/path/to/flowerpower/project\"\nlog_level: \"INFO\"\n</code></pre> <p>This configuration can be loaded by both the CLI and the programmatic API, ensuring consistency across different usage patterns. The configuration is validated using <code>msgspec</code> for robust error checking.</p>"},{"location":"core-concepts/#statistics-and-monitoring","title":"Statistics and Monitoring","text":"<p><code>flowerpower-mqtt</code> provides built-in mechanisms for monitoring its operation and gathering statistics. This includes:</p> <ul> <li>Message Counts: Tracks the total number of messages received and the count per subscription.</li> <li>Pipeline Execution Counts: Records how many pipelines have been triggered.</li> <li>Error Counts: Logs errors encountered during message processing or pipeline execution.</li> <li>Connection Status: Indicates whether the plugin is currently connected to the MQTT broker.</li> <li>Job Queue Status: Provides insights into the state of the job queue if enabled.</li> </ul> <p>These statistics are accessible via both the CLI (<code>flowerpower-mqtt status</code>, <code>flowerpower-mqtt monitor</code>) and the programmatic API (<code>MQTTPlugin.get_statistics()</code>, <code>MQTTPlugin.get_subscriptions()</code>), allowing you to integrate monitoring into your existing dashboards or scripts.</p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides a gallery of practical, copy-paste-friendly examples covering common use cases for <code>flowerpower-mqtt</code>, demonstrating both CLI and programmatic approaches.</p>"},{"location":"examples/#1-simple-synchronous-listener-programmatic","title":"1. Simple Synchronous Listener (Programmatic)","text":"<p>This example sets up a basic MQTT listener that processes messages synchronously.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Create plugin instance\n    mqtt = MQTTPlugin(\n        broker=\"localhost\",\n        base_dir=\"/path/to/your/flowerpower/project\" # IMPORTANT: Replace with your FlowerPower project path\n    )\n\n    # Connect to broker\n    await mqtt.connect()\n\n    # Subscribe to a topic with default synchronous execution\n    await mqtt.subscribe(\"sensor/temperature\", \"process_temperature_pipeline\")\n\n    print(\"Listening for MQTT messages on 'sensor/temperature' (synchronous execution)...\")\n    print(\"Press Ctrl+C to stop.\")\n\n    # Start listening (blocks until Ctrl+C)\n    await mqtt.start_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#2-asynchronous-processing-with-rq-programmatic","title":"2. Asynchronous Processing with RQ (Programmatic)","text":"<p>This example demonstrates how to enable the RQ job queue for asynchronous pipeline execution, suitable for long-running tasks.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Create plugin with RQ job queue enabled\n    mqtt = MQTTPlugin(\n        broker=\"mqtt.example.com\", # Replace with your MQTT broker\n        base_dir=\"/path/to/your/flowerpower/project\", # IMPORTANT: Replace with your FlowerPower project path\n        use_job_queue=True,\n        redis_url=\"redis://localhost:6379\" # Replace if your Redis is elsewhere\n    )\n\n    await mqtt.connect()\n\n    # Subscribe with async execution mode\n    await mqtt.subscribe(\"data/sensor\", \"process_sensor_data\", qos=1, execution_mode=\"async\")\n\n    print(\"Listening for MQTT messages on 'data/sensor' (asynchronous execution via RQ)...\")\n    print(\"Ensure an RQ worker is running: `rq worker mqtt_pipelines --url redis://localhost:6379`\")\n\n    # Start listener in background\n    await mqtt.start_listener(background=True)\n\n    # Keep the main loop running to allow background listener to operate\n    print(\"Listener running in background. Doing other work for 60 seconds...\")\n    await asyncio.sleep(60) # Simulate other application work\n\n    print(\"Stopping listener...\")\n    await mqtt.stop_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#3-using-a-configuration-file-programmatic","title":"3. Using a Configuration File (Programmatic)","text":"<p>This example shows how to load <code>flowerpower-mqtt</code> configuration from a YAML file, promoting easier management and deployment.</p> <p>First, create a <code>config.yml</code> file:</p> <pre><code># config.yml\nmqtt:\n  broker: \"localhost\"\n  port: 1883\n\nsubscriptions:\n  - topic: \"device/+/status\"\n    pipeline: \"update_device_status\"\n    qos: 0\n    execution_mode: \"sync\"\n  - topic: \"alerts/high\"\n    pipeline: \"send_alert_notification\"\n    qos: 1\n    execution_mode: \"async\"\n\njob_queue:\n  enabled: true\n  redis_url: \"redis://localhost:6379\"\n  queue_name: \"mqtt_jobs\"\n\nbase_dir: \"/path/to/your/flowerpower/project\" # IMPORTANT: Replace with your FlowerPower project path\nlog_level: \"INFO\"\n</code></pre> <p>Then, use it in your Python script:</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Load from configuration file\n    mqtt = MQTTPlugin.from_config(\"config.yml\")\n\n    await mqtt.connect()\n    print(\"Connected and configured from config.yml. Starting listener...\")\n    await mqtt.start_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#4-mixed-mode-processing-based-on-qos-programmatic","title":"4. Mixed-Mode Processing Based on QoS (Programmatic)","text":"<p>This example demonstrates how to use the <code>mixed</code> execution mode, where QoS 2 messages are processed synchronously, and QoS 0/1 messages are processed asynchronously.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    mqtt = MQTTPlugin(\n        broker=\"localhost\",\n        base_dir=\"/path/to/your/flowerpower/project\", # IMPORTANT: Replace with your FlowerPower project path\n        use_job_queue=True, # Job queue must be enabled for mixed mode\n        redis_url=\"redis://localhost:6379\"\n    )\n\n    await mqtt.connect()\n\n    # Subscribe with mixed execution mode\n    # QoS 2 messages will be sync, QoS 0/1 will be async\n    await mqtt.subscribe(\"critical/q2_data\", \"process_critical_data\", qos=2, execution_mode=\"mixed\")\n    await mqtt.subscribe(\"non_critical/q1_data\", \"process_non_critical_data\", qos=1, execution_mode=\"mixed\")\n\n    print(\"Listening with mixed execution mode...\")\n    print(\"QoS 2 messages -&gt; synchronous pipeline execution.\")\n    print(\"QoS 0/1 messages -&gt; asynchronous pipeline execution via RQ.\")\n\n    await mqtt.start_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#5-cli-only-workflow","title":"5. CLI-Only Workflow","text":"<p>This workflow demonstrates how to manage <code>flowerpower-mqtt</code> entirely from the command line.</p> <ol> <li> <p>Create Configuration (Interactive)</p> <p><pre><code>flowerpower-mqtt config create --interactive --output my_cli_config.yml\n</code></pre> Follow the prompts to set up your broker, base directory, and optionally enable the job queue.</p> </li> <li> <p>Connect to Broker</p> <pre><code>flowerpower-mqtt connect --config my_cli_config.yml\n</code></pre> </li> <li> <p>Add Subscriptions</p> <p><pre><code>flowerpower-mqtt subscribe \"sensors/light\" process_light_data --qos 0 --mode sync --config my_cli_config.yml --save-config\nflowerpower-mqtt subscribe \"sensors/humidity\" process_humidity_data --qos 1 --mode async --config my_cli_config.yml --save-config\n</code></pre> The <code>--save-config</code> flag updates <code>my_cli_config.yml</code> with the new subscriptions.</p> </li> <li> <p>Start Listener in Background</p> <pre><code>flowerpower-mqtt listen --background --config my_cli_config.yml &amp;\n</code></pre> </li> <li> <p>Monitor Status</p> <p><pre><code>flowerpower-mqtt monitor --config my_cli_config.yml\n</code></pre> Press <code>Ctrl+C</code> to stop monitoring.</p> </li> <li> <p>Check Job Queue Status (if enabled)</p> <pre><code>flowerpower-mqtt jobs status --config my_cli_config.yml\n</code></pre> </li> <li> <p>Disconnect</p> <pre><code>flowerpower-mqtt disconnect --config my_cli_config.yml\n</code></pre> </li> </ol>"},{"location":"examples/#6-hybrid-workflow-cli-for-setup-python-for-logic","title":"6. Hybrid Workflow (CLI for Setup, Python for Logic)","text":"<p>This approach combines the ease of CLI configuration with the flexibility of programmatic control.</p> <ol> <li> <p>Generate Configuration via CLI</p> <p>Use the CLI to create and validate your <code>flowerpower-mqtt</code> configuration. This is especially useful for setting up complex MQTT and job queue parameters.</p> <pre><code>flowerpower-mqtt config create --interactive --output hybrid_config.yml\nflowerpower-mqtt config validate hybrid_config.yml\n</code></pre> </li> <li> <p>Load and Extend in Python</p> <p>Load the CLI-generated configuration in your Python application and add custom business logic or dynamic subscriptions.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Load the configuration generated by the CLI\n    mqtt = MQTTPlugin.from_config(\"hybrid_config.yml\")\n\n    await mqtt.connect()\n\n    # Add dynamic subscriptions or override existing ones\n    await mqtt.subscribe(\"custom/topic\", \"custom_pipeline\", qos=1)\n\n    # Implement custom application logic here\n    print(\"Hybrid application running. Listening for messages...\")\n\n    # Start the listener (can be background or foreground)\n    await mqtt.start_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> </li> </ol>"},{"location":"flowerpower-integration/","title":"FlowerPower Integration","text":"<p><code>flowerpower-mqtt</code> is designed to seamlessly integrate with the <code>flowerpower</code> library, enabling you to trigger and execute your data pipelines based on incoming MQTT messages. This section explains how <code>flowerpower-mqtt</code> interacts with your FlowerPower projects and provides guidance on designing pipelines for MQTT data.</p>"},{"location":"flowerpower-integration/#pipeline-input","title":"Pipeline Input","text":"<p>When an MQTT message is received and processed by <code>flowerpower-mqtt</code>, the data from that message is passed as input to your designated FlowerPower pipeline. <code>flowerpower-mqtt</code> enriches this input with additional metadata, making it easy for your pipelines to access relevant information about the MQTT message.</p> <p>The inputs provided to your FlowerPower pipeline will include:</p> <ul> <li><code>mqtt_message</code> (<code>dict</code>): The parsed payload of the MQTT message. If the payload is valid JSON, it will be parsed into a Python dictionary. Otherwise, it will contain <code>raw_payload</code> (bytes) and <code>payload_str</code> (string representation).</li> <li><code>mqtt_topic</code> (<code>str</code>): The full MQTT topic on which the message was received.</li> <li><code>mqtt_qos</code> (<code>int</code>): The Quality of Service (QoS) level of the received MQTT message (0, 1, or 2).</li> <li><code>execution_timestamp</code> (<code>str</code>): An ISO-formatted timestamp indicating when the message was processed by <code>flowerpower-mqtt</code>.</li> <li><code>execution_mode</code> (<code>str</code>): The execution mode (<code>sync</code>, <code>async</code>, or <code>mixed</code>) that triggered the pipeline.</li> </ul>"},{"location":"flowerpower-integration/#example-pipeline","title":"Example Pipeline","text":"<p>Here's an example of a FlowerPower pipeline that demonstrates how to access and process the MQTT message data provided by <code>flowerpower-mqtt</code>.</p> <p>Assume you have a pipeline defined in your <code>pipelines/</code> directory (e.g., <code>pipelines/sensor_processor.py</code>):</p> <pre><code># pipelines/sensor_processor.py\nimport pandas as pd\nfrom hamilton.function_modifiers import parameterize\nfrom typing import Dict, Any\n\ndef process_mqtt_message(\n    mqtt_message: Dict[str, Any], \n    mqtt_topic: str, \n    mqtt_qos: int,\n    execution_timestamp: str\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Process incoming MQTT message data.\n\n    This function receives the parsed MQTT message payload and metadata.\n    \"\"\"\n    print(f\"Received message from {mqtt_topic} (QoS {mqtt_qos}) at {execution_timestamp}\")\n\n    # Access message payload\n    sensor_data = mqtt_message.get(\"sensor_data\", {})\n\n    # Perform some processing\n    processed_data = {\n        \"processed_at\": execution_timestamp,\n        \"source_topic\": mqtt_topic,\n        \"temperature_celsius\": sensor_data.get(\"temperature\"),\n        \"humidity_percent\": sensor_data.get(\"humidity\"),\n        \"status\": \"processed\"\n    }\n\n    return processed_data\n\ndef save_results(process_mqtt_message: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Save the processed results.\n\n    This function could save data to a database, file, or send it to another service.\n    \"\"\"\n    # Example: Print to console\n    print(f\"Saving results for topic {process_mqtt_message['source_topic']}:\")\n    print(f\"  Temperature: {process_mqtt_message.get('temperature_celsius')}\u00b0C\")\n    print(f\"  Humidity: {process_mqtt_message.get('humidity_percent')}%\")\n\n    # In a real application, you would save this data persistently\n    # e.g., to a database:\n    # db.insert_sensor_reading(process_mqtt_message)\n\n    return f\"Results saved for {process_mqtt_message['source_topic']}\"\n\n# You can also define a full pipeline using Hamilton's @parameterize\n# For more complex pipelines, refer to the FlowerPower documentation.\n</code></pre> <p>To link this pipeline, you would configure your <code>flowerpower-mqtt</code> subscription like this:</p> <pre><code># mqtt_config.yml\nsubscriptions:\n  - topic: \"sensors/+/data\"\n    pipeline: \"sensor_processor\" # Matches the name of your pipeline module\n    qos: 1\n    execution_mode: \"async\" # Or \"sync\", \"mixed\"\n</code></pre>"},{"location":"flowerpower-integration/#best-practices-for-pipelines","title":"Best Practices for Pipelines","text":"<ul> <li>Idempotency: Design your pipelines to be idempotent, especially if using QoS 1 (at least once delivery) or asynchronous processing, where messages might be processed multiple times due to retries.</li> <li>Error Handling: Implement robust error handling within your pipelines. If a pipeline fails, <code>flowerpower-mqtt</code> will log the error, and if using an asynchronous job queue, the job might be retried based on your RQ configuration.</li> <li>Modularity: Break down complex processing into smaller, reusable FlowerPower functions.</li> <li>Input Validation: Validate the <code>mqtt_message</code> payload within your pipeline functions to ensure it conforms to your expected schema.</li> <li>Logging: Use standard Python logging within your pipelines to provide visibility into their execution.</li> <li>Performance: For high-throughput scenarios, optimize your pipelines for performance and consider using asynchronous execution with a job queue.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you quickly set up and start using <code>flowerpower-mqtt</code> for both CLI and programmatic usage.</p>"},{"location":"getting-started/#quick-start-cli","title":"Quick Start: CLI","text":"<p>The fastest way to get started with <code>flowerpower-mqtt</code> is by using its powerful command-line interface.</p> <ol> <li> <p>Create Configuration Interactively</p> <p>This command guides you through creating a basic <code>mqtt_config.yml</code> file.</p> <pre><code>flowerpower-mqtt config create --interactive\n</code></pre> <p>You'll be prompted for details like your MQTT broker hostname, port, and whether to enable the job queue.</p> </li> <li> <p>Connect to MQTT Broker</p> <p>Use your newly created configuration file to connect to the MQTT broker.</p> <pre><code>flowerpower-mqtt connect --config mqtt_config.yml\n</code></pre> </li> <li> <p>Subscribe to Topics</p> <p>Subscribe to an MQTT topic and link it to a FlowerPower pipeline. Replace <code>\"sensors/+/temperature\"</code> with your desired topic pattern and <code>\"temperature_processor\"</code> with the name of your FlowerPower pipeline.</p> <pre><code>flowerpower-mqtt subscribe \"sensors/+/temperature\" temperature_processor --qos 1\n</code></pre> </li> <li> <p>Start Listening</p> <p>Begin listening for incoming MQTT messages. This command will block until you press <code>Ctrl+C</code>.</p> <pre><code>flowerpower-mqtt listen\n</code></pre> <p>For asynchronous processing with a job queue, you would typically start an RQ worker in a separate terminal:</p> <pre><code># In a separate terminal\nrq worker mqtt_pipelines --url redis://localhost:6379\n</code></pre> <p>Then, you can start the <code>flowerpower-mqtt</code> listener in the background:</p> <pre><code>flowerpower-mqtt listen --background &amp;\nflowerpower-mqtt monitor --interval 5\n</code></pre> </li> </ol>"},{"location":"getting-started/#quick-start-programmatic-usage","title":"Quick Start: Programmatic Usage","text":"<p>For integrating <code>flowerpower-mqtt</code> into your Python applications, use its programmatic API.</p> <ol> <li> <p>Basic Synchronous Usage</p> <p>This example demonstrates how to connect to an MQTT broker, subscribe to a topic, and start listening for messages synchronously.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Create plugin instance\n    mqtt = MQTTPlugin(\n        broker=\"localhost\",\n        base_dir=\"/path/to/flowerpower/project\" # Replace with your FlowerPower project path\n    )\n\n    # Connect to broker\n    await mqtt.connect()\n\n    # Subscribe to topic\n    await mqtt.subscribe(\"sensors/temperature\", \"temperature_pipeline\", qos=1)\n\n    # Start listening (blocks until Ctrl+C)\n    await mqtt.start_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> </li> <li> <p>Asynchronous Usage with Job Queue</p> <p>This example shows how to enable the RQ job queue for asynchronous pipeline execution.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Create plugin with RQ job queue enabled\n    mqtt = MQTTPlugin(\n        broker=\"mqtt.example.com\",\n        base_dir=\"/path/to/flowerpower/project\", # Replace with your FlowerPower project path\n        use_job_queue=True,\n        redis_url=\"redis://localhost:6379\"\n    )\n\n    await mqtt.connect()\n\n    # Subscribe with async execution\n    await mqtt.subscribe(\"sensors/+/data\", \"sensor_processor\", qos=1, execution_mode=\"async\")\n    await mqtt.subscribe(\"alerts/critical\", \"alert_handler\", qos=2, execution_mode=\"sync\")\n\n    # Start listener in background\n    await mqtt.start_listener(background=True)\n\n    # Do other work...\n    await asyncio.sleep(60)\n\n    # Stop gracefully\n    await mqtt.stop_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> </li> </ol>"},{"location":"getting-started/#core-workflow","title":"Core Workflow","text":"<p>The typical workflow for <code>flowerpower-mqtt</code> involves these steps:</p> <pre><code>graph TD\n    A[Configure `flowerpower-mqtt`] --&gt; B[Connect to MQTT Broker]\n    B --&gt; C[Subscribe to MQTT Topics]\n    C --&gt; D[Start Listening for Messages]\n    D -- Triggers --&gt; E[Execute FlowerPower Pipelines]</code></pre> <p>This workflow can be managed entirely via the CLI, programmatically within your Python applications, or through a hybrid approach.</p>"},{"location":"installation/","title":"Installation","text":"<p>This section details how to install <code>flowerpower-mqtt</code> and its dependencies.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing <code>flowerpower-mqtt</code>, ensure you have the following:</p> <ul> <li>Python: Version 3.11 or higher.</li> <li>FlowerPower: The core <code>flowerpower</code> library must be installed.</li> <li>Redis: Required for job queue functionality (asynchronous processing). You'll need a running Redis instance accessible from where <code>flowerpower-mqtt</code> will operate.</li> </ul>"},{"location":"installation/#recommended-installation-from-pypi","title":"Recommended Installation (from PyPI)","text":"<p><code>flowerpower-mqtt</code> is available on PyPI and can be installed using <code>uv pip</code> (recommended) or <code>pip</code>.</p>"},{"location":"installation/#using-uv-pip-recommended","title":"Using <code>uv pip</code> (Recommended)","text":"<p><code>uv</code> is a fast Python package installer and resolver. It's the recommended way to install <code>flowerpower-mqtt</code>.</p> <pre><code>uv pip install flowerpower-mqtt\n</code></pre>"},{"location":"installation/#using-pip","title":"Using <code>pip</code>","text":"<p>If you prefer using <code>pip</code>, you can install <code>flowerpower-mqtt</code> directly:</p> <pre><code>pip install flowerpower-mqtt\n</code></pre> <p>After installation, the <code>flowerpower-mqtt</code> CLI command will be available in your environment.</p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you plan to contribute to <code>flowerpower-mqtt</code> or want to set up a development environment, follow these steps:</p> <ol> <li> <p>Clone the Repository</p> <pre><code>git clone https://github.com/legout/flowerpower-mqtt.git\ncd flowerpower-mqtt\n</code></pre> </li> <li> <p>Install Development Dependencies</p> <pre><code>uv pip install -e \".[dev]\"\n</code></pre> <p>This command installs the core library in editable mode along with development-specific dependencies like <code>pytest</code>, <code>black</code>, <code>ruff</code>, and <code>mypy</code>.</p> </li> </ol>"},{"location":"installation/#shell-completion","title":"Shell Completion","text":"<p>The <code>flowerpower-mqtt</code> CLI supports shell completion for various shells (bash, zsh, fish, powershell). To enable it, follow the instructions provided by <code>typer</code> for your specific shell.</p> <p>For example, for <code>bash</code>:</p> <pre><code>flowerpower-mqtt --install-completion bash\n</code></pre> <p>Remember to restart your shell or source your shell's RC file (e.g., <code>.bashrc</code>, <code>.zshrc</code>) after installation for the changes to take effect.</p>"},{"location":"monitoring/","title":"Monitoring","text":"<p><code>flowerpower-mqtt</code> provides built-in capabilities for monitoring its operation, including connection status, message counts, pipeline execution statistics, and error tracking. This allows you to gain insights into the health and performance of your MQTT-driven data processing workflows.</p> <p>Monitoring information is accessible through both the Command Line Interface (CLI) and the programmatic API.</p>"},{"location":"monitoring/#cli-monitoring","title":"CLI Monitoring","text":"<p>The <code>flowerpower-mqtt</code> CLI offers two primary commands for monitoring: <code>status</code> for a snapshot view and <code>monitor</code> for real-time updates.</p>"},{"location":"monitoring/#flowerpower-mqtt-status","title":"<code>flowerpower-mqtt status</code>","text":"<p>This command provides a summary of the current plugin status and key statistics.</p> <pre><code>flowerpower-mqtt status\n</code></pre> <p>Example Output:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Plugin Status \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Property             Value                                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Connected            \u2705 Yes                                        \u2502\n\u2502 Broker               localhost:1883                               \u2502\n\u2502 Listening            \u2705 Yes                                        \u2502\n\u2502 Runtime              360.5s                                       \u2502\n\u2502 Messages             1250                                         \u2502\n\u2502 Pipelines Executed   1245                                         \u2502\n\u2502 Errors               5                                            \u2502\n\u2502 Subscriptions        2                                            \u2502\n\u2502 Job Queue            \u2705 Enabled                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Subscription Details \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Topic                 Pipeline            QoS   Mode    Messages  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 sensors/temperature   process_temp_data   1     async   750       \u2502\n\u2502 alerts/critical       handle_alert        2     sync    495       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Specify a configuration file to use.</li> <li> <p><code>--json</code> (<code>bool</code>): Output the status as a machine-readable JSON object. This is useful for integrating with other monitoring systems or for scripting.</p> <pre><code>flowerpower-mqtt status --json\n</code></pre> </li> </ul>"},{"location":"monitoring/#flowerpower-mqtt-monitor","title":"<code>flowerpower-mqtt monitor</code>","text":"<p>The <code>monitor</code> command provides a real-time, continuously updating view of the plugin's statistics and active subscription activity.</p> <pre><code>flowerpower-mqtt monitor [OPTIONS]\n</code></pre> <p>Example Output (continuously updates):</p> <pre><code>Monitor #1 - 1678886400.0\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Real-time Statistics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Metric               Value                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Connected            \u2705 Yes                                          \u2502\n\u2502 Listening            \u2705 Yes                                          \u2502\n\u2502 Runtime              365.1s                                         \u2502\n\u2502 Messages             1260                                           \u2502\n\u2502 Pipeline Executions  1255                                           \u2502\n\u2502 Errors               5                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Active Subscriptions \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Topic                 Messages   Pipeline                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 sensors/temperature   755        process_temp_data                    \u2502\n\u2502 alerts/critical       498        handle_alert                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nPress Ctrl+C to stop monitoring...\n</code></pre> <p>Options:</p> <ul> <li><code>--config</code>, <code>-c</code> (<code>Path</code>): Specify a configuration file to use.</li> <li><code>--interval</code>, <code>-i</code> (<code>int</code>): The update frequency in seconds (default: <code>5</code>).</li> <li><code>--duration</code>, <code>-d</code> (<code>int</code>): The total duration in seconds for which to monitor. If not specified, monitoring runs indefinitely until <code>Ctrl+C</code> is pressed.</li> <li> <p><code>--json</code> (<code>bool</code>): Output real-time monitoring data as JSON. Each update will print a new JSON object to standard output.</p> <pre><code>flowerpower-mqtt monitor --interval 1 --json\n</code></pre> </li> </ul>"},{"location":"monitoring/#programmatic-statistics","title":"Programmatic Statistics","text":"<p>You can retrieve the same statistics and subscription information programmatically using methods of the <code>MQTTPlugin</code> instance.</p>"},{"location":"monitoring/#get_statistics","title":"<code>get_statistics()</code>","text":"<p>Returns a dictionary containing overall plugin statistics.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    mqtt = MQTTPlugin(broker=\"localhost\", base_dir=\".\")\n    await mqtt.connect()\n\n    stats = mqtt.get_statistics()\n    print(f\"Connected: {stats['connected']}\")\n    print(f\"Total Messages Received: {stats['message_count']}\")\n    print(f\"Pipelines Executed: {stats['pipeline_count']}\")\n    print(f\"Errors: {stats['error_count']}\")\n    print(f\"Listener Running: {stats['running']}\")\n    print(f\"Runtime: {stats['runtime_seconds']:.2f} seconds\")\n\n    if stats.get(\"job_queue_enabled\"):\n        print(f\"Job Queue Enabled: Yes\")\n        print(f\"  Queue Name: {stats['job_queue_stats']['queue_name']}\")\n\n    await mqtt.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Returns:</p> <ul> <li><code>Dict[str, Any]</code>: A dictionary with the following keys:<ul> <li><code>connected</code> (<code>bool</code>): Whether the plugin is connected to the MQTT broker.</li> <li><code>broker</code> (<code>str</code>): The broker address and port.</li> <li><code>running</code> (<code>bool</code>): Whether the listener is active.</li> <li><code>start_time</code> (<code>str</code>, optional): ISO formatted timestamp when the listener started.</li> <li><code>runtime_seconds</code> (<code>float</code>, optional): How long the listener has been running.</li> <li><code>message_count</code> (<code>int</code>): Total number of MQTT messages processed.</li> <li><code>pipeline_count</code> (<code>int</code>): Total number of pipelines executed (synchronously or asynchronously).</li> <li><code>error_count</code> (<code>int</code>): Total number of errors encountered.</li> <li><code>subscriptions</code> (<code>int</code>): Number of active subscriptions.</li> <li><code>job_queue_enabled</code> (<code>bool</code>): Whether the job queue is enabled.</li> <li><code>job_queue_stats</code> (<code>Dict</code>, optional): Dictionary with job queue specific statistics (e.g., <code>queue_name</code>, <code>type</code>).</li> </ul> </li> </ul>"},{"location":"monitoring/#get_subscriptions","title":"<code>get_subscriptions()</code>","text":"<p>Returns a list of dictionaries, each providing detailed information and runtime statistics for an individual subscription.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    mqtt = MQTTPlugin(broker=\"localhost\", base_dir=\".\")\n    await mqtt.connect()\n    await mqtt.subscribe(\"sensor/data\", \"process_sensor\")\n    await mqtt.subscribe(\"alert/high\", \"handle_alert\")\n\n    # Simulate some messages\n    # In a real scenario, messages would come from the broker\n    # For demonstration, manually update counts (not how it works in practice)\n    mqtt.get_subscriptions()[0]['message_count'] = 10\n    mqtt.get_subscriptions()[1]['message_count'] = 3\n\n    subscriptions_info = mqtt.get_subscriptions()\n    for sub in subscriptions_info:\n        print(f\"Topic: {sub['topic']}\")\n        print(f\"  Pipeline: {sub['pipeline']}\")\n        print(f\"  QoS: {sub['qos']}\")\n        print(f\"  Mode: {sub['execution_mode']}\")\n        print(f\"  Messages Received: {sub['message_count']}\")\n        print(f\"  Errors: {sub['error_count']}\")\n        print(\"-\" * 20)\n\n    await mqtt.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Returns:</p> <ul> <li><code>List[Dict[str, Any]]</code>: A list of dictionaries. Each dictionary represents a subscription and includes:<ul> <li><code>topic</code> (<code>str</code>): The subscribed MQTT topic pattern.</li> <li><code>pipeline</code> (<code>str</code>): The name of the associated FlowerPower pipeline.</li> <li><code>qos</code> (<code>int</code>): The QoS level of the subscription.</li> <li><code>execution_mode</code> (<code>str</code>): The execution mode for the pipeline.</li> <li><code>message_count</code> (<code>int</code>): Number of messages received on this topic.</li> <li><code>last_message_time</code> (<code>float</code>, optional): Timestamp of the last message received.</li> <li><code>error_count</code> (<code>int</code>): Number of errors encountered for this subscription.</li> </ul> </li> </ul>"},{"location":"monitoring/#interpreting-monitoring-data","title":"Interpreting Monitoring Data","text":"<ul> <li><code>message_count</code> vs. <code>pipeline_count</code>: A significant discrepancy might indicate issues with pipeline execution (e.g., pipelines failing or taking too long, leading to messages being dropped or not processed).</li> <li><code>error_count</code>: Monitor this closely. Non-zero values indicate problems with message handling or pipeline execution. Check logs for details.</li> <li><code>runtime_seconds</code>: Provides an idea of how long the plugin has been actively running and processing messages.</li> <li>Job Queue Statistics: If using asynchronous processing, monitor the job queue itself (e.g., RQ dashboard, <code>rqinfo</code>) to check queue length, worker health, and job failures.</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section provides auto-generated API documentation for <code>flowerpower-mqtt</code>.</p> <p>The documentation is generated from the source code docstrings using <code>mkdocstrings</code>.</p>"},{"location":"api/#flowerpower_mqtt","title":"flowerpower_mqtt","text":"<p>FlowerPower MQTT Plugin</p> <p>A simple MQTT plugin for FlowerPower that triggers pipeline execution when messages arrive on subscribed topics, with configurable QoS levels and optional RQ job queue integration for asynchronous processing.</p>"},{"location":"api/#flowerpower_mqtt-classes","title":"Classes","text":""},{"location":"api/#flowerpower_mqtt.FlowerPowerMQTTConfig","title":"FlowerPowerMQTTConfig","text":"<p>               Bases: <code>Struct</code></p> <p>Main configuration for FlowerPower MQTT plugin.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class FlowerPowerMQTTConfig(Struct):\n    \"\"\"Main configuration for FlowerPower MQTT plugin.\"\"\"\n    mqtt: MQTTConfig = MQTTConfig()\n    job_queue: JobQueueConfig = JobQueueConfig()\n    subscriptions: List[SubscriptionConfig] = msgspec.field(default_factory=list)\n    base_dir: str = \".\"\n    log_level: str = \"INFO\"\n\n    @classmethod\n    def from_yaml(cls, file_path: Path) -&gt; \"FlowerPowerMQTTConfig\":\n        \"\"\"Load configuration from YAML file.\"\"\"\n        if not file_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {file_path}\")\n\n        with open(file_path, 'r') as f:\n            data = yaml.safe_load(f)\n\n        # Convert nested dictionaries to proper types\n        return msgspec.convert(data, cls)\n\n    def to_yaml(self, file_path: Path) -&gt; None:\n        \"\"\"Save configuration to YAML file.\"\"\"\n        # Convert struct to dictionary\n        data = msgspec.to_builtins(self)\n\n        with open(file_path, 'w') as f:\n            yaml.dump(data, f, default_flow_style=False, indent=2)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for compatibility.\"\"\"\n        return msgspec.to_builtins(self)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.FlowerPowerMQTTConfig-functions","title":"Functions","text":""},{"location":"api/#flowerpower_mqtt.FlowerPowerMQTTConfig.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(file_path: Path) -&gt; FlowerPowerMQTTConfig\n</code></pre> <p>Load configuration from YAML file.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>@classmethod\ndef from_yaml(cls, file_path: Path) -&gt; \"FlowerPowerMQTTConfig\":\n    \"\"\"Load configuration from YAML file.\"\"\"\n    if not file_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {file_path}\")\n\n    with open(file_path, 'r') as f:\n        data = yaml.safe_load(f)\n\n    # Convert nested dictionaries to proper types\n    return msgspec.convert(data, cls)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.FlowerPowerMQTTConfig.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml(file_path: Path) -&gt; None\n</code></pre> <p>Save configuration to YAML file.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>def to_yaml(self, file_path: Path) -&gt; None:\n    \"\"\"Save configuration to YAML file.\"\"\"\n    # Convert struct to dictionary\n    data = msgspec.to_builtins(self)\n\n    with open(file_path, 'w') as f:\n        yaml.dump(data, f, default_flow_style=False, indent=2)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.FlowerPowerMQTTConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert to dictionary for compatibility.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for compatibility.\"\"\"\n    return msgspec.to_builtins(self)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTConfig","title":"MQTTConfig","text":"<p>               Bases: <code>Struct</code></p> <p>MQTT broker configuration.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class MQTTConfig(Struct):\n    \"\"\"MQTT broker configuration.\"\"\"\n    broker: str = \"localhost\"\n    port: int = 1883\n    keepalive: int = 60\n    client_id: Optional[str] = None\n    clean_session: bool = True\n    username: Optional[str] = None\n    password: Optional[str] = None\n    reconnect_retries: int = 5\n    reconnect_delay: int = 5\n</code></pre>"},{"location":"api/#flowerpower_mqtt.JobQueueConfig","title":"JobQueueConfig","text":"<p>               Bases: <code>Struct</code></p> <p>Job queue configuration.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class JobQueueConfig(Struct):\n    \"\"\"Job queue configuration.\"\"\"\n    enabled: bool = False\n    type: str = \"rq\"\n    redis_url: str = \"redis://localhost:6379\"\n    queue_name: str = \"mqtt_pipelines\"\n    worker_count: int = 4\n    max_retries: int = 3\n</code></pre>"},{"location":"api/#flowerpower_mqtt.SubscriptionConfig","title":"SubscriptionConfig","text":"<p>               Bases: <code>Struct</code></p> <p>Individual subscription configuration.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class SubscriptionConfig(Struct):\n    \"\"\"Individual subscription configuration.\"\"\"\n    topic: str\n    pipeline: str\n    qos: Annotated[int, Meta(extra=_validate_qos)] = 0\n    execution_mode: Annotated[str, Meta(extra=_validate_execution_mode)] = \"sync\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for compatibility.\"\"\"\n        return msgspec.to_builtins(self)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.SubscriptionConfig-functions","title":"Functions","text":""},{"location":"api/#flowerpower_mqtt.SubscriptionConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert to dictionary for compatibility.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for compatibility.\"\"\"\n    return msgspec.to_builtins(self)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.FlowerPowerMQTTError","title":"FlowerPowerMQTTError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for FlowerPower MQTT plugin.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class FlowerPowerMQTTError(Exception):\n    \"\"\"Base exception for FlowerPower MQTT plugin.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when MQTT connection fails.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class ConnectionError(FlowerPowerMQTTError):\n    \"\"\"Raised when MQTT connection fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.SubscriptionError","title":"SubscriptionError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when MQTT subscription fails.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class SubscriptionError(FlowerPowerMQTTError):\n    \"\"\"Raised when MQTT subscription fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.ConfigurationError","title":"ConfigurationError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when configuration is invalid.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class ConfigurationError(FlowerPowerMQTTError):\n    \"\"\"Raised when configuration is invalid.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin","title":"MQTTPlugin","text":"<p>Main interface for FlowerPower MQTT plugin.</p> <p>Provides simple API for connecting to MQTT brokers, subscribing to topics, and triggering FlowerPower pipeline execution with support for different QoS levels and execution modes.</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>class MQTTPlugin:\n    \"\"\"\n    Main interface for FlowerPower MQTT plugin.\n\n    Provides simple API for connecting to MQTT brokers, subscribing to topics,\n    and triggering FlowerPower pipeline execution with support for different\n    QoS levels and execution modes.\n    \"\"\"\n\n    def __init__(\n        self,\n        broker: str = \"localhost\",\n        port: int = 1883,\n        base_dir: str = \".\",\n        use_job_queue: bool = False,\n        redis_url: str = \"redis://localhost:6379\",\n        config: Optional[FlowerPowerMQTTConfig] = None,\n        **mqtt_kwargs\n    ):\n        \"\"\"\n        Initialize MQTT plugin.\n\n        Args:\n            broker: MQTT broker hostname\n            port: MQTT broker port\n            base_dir: FlowerPower project base directory\n            use_job_queue: Enable RQ job queue for async execution\n            redis_url: Redis connection URL for job queue\n            config: Complete configuration object (overrides other params)\n            **mqtt_kwargs: Additional MQTT client configuration\n        \"\"\"\n        # Handle Windows event loop policy for aiomqtt\n        if sys.platform.lower() == \"win32\" or os.name.lower() == \"nt\":\n            try:\n                from asyncio import set_event_loop_policy, WindowsSelectorEventLoopPolicy\n                set_event_loop_policy(WindowsSelectorEventLoopPolicy())\n            except ImportError:\n                logger.warning(\"Could not set Windows event loop policy\")\n\n        # Initialize configuration\n        if config is not None:\n            self.config = config\n        else:\n            mqtt_config = MQTTConfig(\n                broker=broker,\n                port=port,\n                **mqtt_kwargs\n            )\n\n            job_queue_config = JobQueueConfig(\n                enabled=use_job_queue,\n                redis_url=redis_url\n            ) if use_job_queue else JobQueueConfig()\n\n            self.config = FlowerPowerMQTTConfig(\n                mqtt=mqtt_config,\n                job_queue=job_queue_config,\n                base_dir=base_dir\n            )\n\n        # Initialize components\n        self.mqtt_client = MQTTClient(self.config.mqtt)\n        self.listener: Optional[MQTTListener] = None\n        self._connected = False\n\n        # Configure logging level\n        logging.getLogger().setLevel(getattr(logging, self.config.log_level.upper()))\n\n    @classmethod\n    def from_config(cls, config_path: Union[str, Path]) -&gt; \"MQTTPlugin\":\n        \"\"\"\n        Create plugin instance from configuration file.\n\n        Args:\n            config_path: Path to YAML configuration file\n\n        Returns:\n            Configured MQTTPlugin instance\n        \"\"\"\n        config = FlowerPowerMQTTConfig.from_yaml(Path(config_path))\n        return cls(config=config)\n\n    async def connect(self) -&gt; None:\n        \"\"\"Connect to MQTT broker.\"\"\"\n        if self._connected:\n            logger.warning(\"Already connected to MQTT broker\")\n            return\n\n        logger.info(f\"Connecting to MQTT broker at {self.config.mqtt.broker}:{self.config.mqtt.port}\")\n        await self.mqtt_client.connect()\n\n        # Initialize listener\n        self.listener = MQTTListener(self.mqtt_client, self.config)\n        self._connected = True\n\n        logger.info(\"Successfully connected to MQTT broker\")\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from MQTT broker.\"\"\"\n        if not self._connected:\n            logger.warning(\"Not connected to MQTT broker\")\n            return\n\n        logger.info(\"Disconnecting from MQTT broker\")\n\n        # Stop listener if running\n        if self.listener and self.listener.is_running:\n            await self.listener.stop_listener()\n\n        await self.mqtt_client.disconnect()\n        self._connected = False\n\n        logger.info(\"Successfully disconnected from MQTT broker\")\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        await self.disconnect()\n\n    async def subscribe(\n        self,\n        topic: str,\n        pipeline_name: str,\n        qos: int = 0,\n        execution_mode: str = \"sync\"\n    ) -&gt; None:\n        \"\"\"\n        Subscribe to MQTT topic and link to FlowerPower pipeline.\n\n        Args:\n            topic: MQTT topic pattern to subscribe to\n            pipeline_name: Name of FlowerPower pipeline to execute\n            qos: QoS level (0=at most once, 1=at least once, 2=exactly once)\n            execution_mode: Execution mode (sync, async, mixed)\n        \"\"\"\n        if not self._connected:\n            raise ConnectionError(\"Not connected to MQTT broker. Call connect() first.\")\n\n        if qos not in [0, 1, 2]:\n            raise SubscriptionError(f\"Invalid QoS level: {qos}. Must be 0, 1, or 2.\")\n\n        if execution_mode not in [\"sync\", \"async\", \"mixed\"]:\n            raise SubscriptionError(\n                f\"Invalid execution mode: {execution_mode}. Must be 'sync', 'async', or 'mixed'.\"\n            )\n\n        # Add to configuration\n        subscription = SubscriptionConfig(\n            topic=topic,\n            pipeline=pipeline_name,\n            qos=qos,\n            execution_mode=execution_mode\n        )\n        self.config.subscriptions.append(subscription)\n\n        # Subscribe via MQTT client\n        await self.mqtt_client.subscribe(topic, pipeline_name, qos, execution_mode)\n\n        logger.info(\n            f\"Subscribed to '{topic}' -&gt; pipeline '{pipeline_name}' \"\n            f\"(QoS {qos}, {execution_mode} mode)\"\n        )\n\n    async def subscribe_bulk(self, subscriptions: List[Dict[str, Any]]) -&gt; None:\n        \"\"\"\n        Subscribe to multiple topics at once.\n\n        Args:\n            subscriptions: List of subscription dictionaries\n        \"\"\"\n        for sub in subscriptions:\n            await self.subscribe(\n                topic=sub[\"topic\"],\n                pipeline_name=sub[\"pipeline\"],\n                qos=sub.get(\"qos\", 0),\n                execution_mode=sub.get(\"execution_mode\", \"sync\")\n            )\n\n    async def unsubscribe(self, topic: str) -&gt; None:\n        \"\"\"\n        Unsubscribe from MQTT topic.\n\n        Args:\n            topic: MQTT topic pattern to unsubscribe from\n        \"\"\"\n        if not self._connected:\n            raise ConnectionError(\"Not connected to MQTT broker\")\n\n        await self.mqtt_client.unsubscribe(topic)\n\n        # Remove from configuration\n        self.config.subscriptions = [\n            sub for sub in self.config.subscriptions if sub.topic != topic\n        ]\n\n        logger.info(f\"Unsubscribed from '{topic}'\")\n\n    async def start_listener(\n        self,\n        background: bool = False,\n        execution_mode: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"\n        Start listening for MQTT messages.\n\n        Args:\n            background: If True, run listener in background task\n            execution_mode: Override execution mode for all pipelines\n        \"\"\"\n        if not self._connected:\n            raise ConnectionError(\"Not connected to MQTT broker. Call connect() first.\")\n\n        if not self.listener:\n            raise ConfigurationError(\"Listener not initialized\")\n\n        if not self.config.subscriptions:\n            logger.warning(\"No subscriptions configured\")\n\n        # Override execution mode if specified\n        if execution_mode:\n            for sub in self.config.subscriptions:\n                sub.execution_mode = execution_mode\n\n        logger.info(\n            f\"Starting listener with {len(self.config.subscriptions)} subscriptions \"\n            f\"(background={background})\"\n        )\n\n        try:\n            await self.listener.start_listener(background=background)\n        except KeyboardInterrupt:\n            logger.info(\"Received keyboard interrupt, stopping listener\")\n            await self.stop_listener()\n        except Exception as e:\n            logger.error(f\"Error in listener: {e}\")\n            raise\n\n    async def stop_listener(self, timeout: float = 10.0) -&gt; None:\n        \"\"\"\n        Stop MQTT message listener.\n\n        Args:\n            timeout: Maximum time to wait for graceful shutdown\n        \"\"\"\n        if not self.listener:\n            logger.warning(\"No listener to stop\")\n            return\n\n        await self.listener.stop_listener(timeout=timeout)\n\n    def get_subscriptions(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get current subscriptions.\n\n        Returns:\n            List of subscription information dictionaries\n        \"\"\"\n        if not self._connected:\n            return [sub.to_dict() for sub in self.config.subscriptions]\n\n        subscriptions = []\n        for topic, runtime_sub in self.mqtt_client.get_all_subscriptions().items():\n            sub_info = {\n                \"topic\": runtime_sub.topic,\n                \"pipeline\": runtime_sub.pipeline,\n                \"qos\": runtime_sub.qos,\n                \"execution_mode\": runtime_sub.execution_mode,\n                \"message_count\": runtime_sub.message_count,\n                \"last_message_time\": runtime_sub.last_message_time,\n                \"error_count\": runtime_sub.error_count\n            }\n            subscriptions.append(sub_info)\n\n        return subscriptions\n\n    def get_statistics(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get plugin statistics.\n\n        Returns:\n            Dictionary with current statistics\n        \"\"\"\n        stats = {\n            \"connected\": self._connected,\n            \"broker\": f\"{self.config.mqtt.broker}:{self.config.mqtt.port}\",\n            \"subscriptions_count\": len(self.config.subscriptions),\n            \"job_queue_enabled\": self.config.job_queue.enabled\n        }\n\n        if self.listener:\n            stats.update(self.listener.get_statistics())\n\n        return stats\n\n    def save_config(self, file_path: Union[str, Path]) -&gt; None:\n        \"\"\"\n        Save current configuration to YAML file.\n\n        Args:\n            file_path: Path where to save configuration\n        \"\"\"\n        self.config.to_yaml(Path(file_path))\n        logger.info(f\"Configuration saved to {file_path}\")\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if connected to MQTT broker.\"\"\"\n        return self._connected\n\n    @property\n    def is_listening(self) -&gt; bool:\n        \"\"\"Check if listener is running.\"\"\"\n        return self.listener.is_running if self.listener else False\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin-attributes","title":"Attributes","text":""},{"location":"api/#flowerpower_mqtt.MQTTPlugin.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Check if connected to MQTT broker.</p>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.is_listening","title":"is_listening  <code>property</code>","text":"<pre><code>is_listening: bool\n</code></pre> <p>Check if listener is running.</p>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin-functions","title":"Functions","text":""},{"location":"api/#flowerpower_mqtt.MQTTPlugin.__init__","title":"__init__","text":"<pre><code>__init__(broker: str = 'localhost', port: int = 1883, base_dir: str = '.', use_job_queue: bool = False, redis_url: str = 'redis://localhost:6379', config: Optional[FlowerPowerMQTTConfig] = None, **mqtt_kwargs)\n</code></pre> <p>Initialize MQTT plugin.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>str</code> <p>MQTT broker hostname</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>MQTT broker port</p> <code>1883</code> <code>base_dir</code> <code>str</code> <p>FlowerPower project base directory</p> <code>'.'</code> <code>use_job_queue</code> <code>bool</code> <p>Enable RQ job queue for async execution</p> <code>False</code> <code>redis_url</code> <code>str</code> <p>Redis connection URL for job queue</p> <code>'redis://localhost:6379'</code> <code>config</code> <code>Optional[FlowerPowerMQTTConfig]</code> <p>Complete configuration object (overrides other params)</p> <code>None</code> <code>**mqtt_kwargs</code> <p>Additional MQTT client configuration</p> <code>{}</code> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>def __init__(\n    self,\n    broker: str = \"localhost\",\n    port: int = 1883,\n    base_dir: str = \".\",\n    use_job_queue: bool = False,\n    redis_url: str = \"redis://localhost:6379\",\n    config: Optional[FlowerPowerMQTTConfig] = None,\n    **mqtt_kwargs\n):\n    \"\"\"\n    Initialize MQTT plugin.\n\n    Args:\n        broker: MQTT broker hostname\n        port: MQTT broker port\n        base_dir: FlowerPower project base directory\n        use_job_queue: Enable RQ job queue for async execution\n        redis_url: Redis connection URL for job queue\n        config: Complete configuration object (overrides other params)\n        **mqtt_kwargs: Additional MQTT client configuration\n    \"\"\"\n    # Handle Windows event loop policy for aiomqtt\n    if sys.platform.lower() == \"win32\" or os.name.lower() == \"nt\":\n        try:\n            from asyncio import set_event_loop_policy, WindowsSelectorEventLoopPolicy\n            set_event_loop_policy(WindowsSelectorEventLoopPolicy())\n        except ImportError:\n            logger.warning(\"Could not set Windows event loop policy\")\n\n    # Initialize configuration\n    if config is not None:\n        self.config = config\n    else:\n        mqtt_config = MQTTConfig(\n            broker=broker,\n            port=port,\n            **mqtt_kwargs\n        )\n\n        job_queue_config = JobQueueConfig(\n            enabled=use_job_queue,\n            redis_url=redis_url\n        ) if use_job_queue else JobQueueConfig()\n\n        self.config = FlowerPowerMQTTConfig(\n            mqtt=mqtt_config,\n            job_queue=job_queue_config,\n            base_dir=base_dir\n        )\n\n    # Initialize components\n    self.mqtt_client = MQTTClient(self.config.mqtt)\n    self.listener: Optional[MQTTListener] = None\n    self._connected = False\n\n    # Configure logging level\n    logging.getLogger().setLevel(getattr(logging, self.config.log_level.upper()))\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.from_config","title":"from_config  <code>classmethod</code>","text":"<pre><code>from_config(config_path: Union[str, Path]) -&gt; MQTTPlugin\n</code></pre> <p>Create plugin instance from configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Union[str, Path]</code> <p>Path to YAML configuration file</p> required <p>Returns:</p> Type Description <code>MQTTPlugin</code> <p>Configured MQTTPlugin instance</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>@classmethod\ndef from_config(cls, config_path: Union[str, Path]) -&gt; \"MQTTPlugin\":\n    \"\"\"\n    Create plugin instance from configuration file.\n\n    Args:\n        config_path: Path to YAML configuration file\n\n    Returns:\n        Configured MQTTPlugin instance\n    \"\"\"\n    config = FlowerPowerMQTTConfig.from_yaml(Path(config_path))\n    return cls(config=config)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Connect to MQTT broker.</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Connect to MQTT broker.\"\"\"\n    if self._connected:\n        logger.warning(\"Already connected to MQTT broker\")\n        return\n\n    logger.info(f\"Connecting to MQTT broker at {self.config.mqtt.broker}:{self.config.mqtt.port}\")\n    await self.mqtt_client.connect()\n\n    # Initialize listener\n    self.listener = MQTTListener(self.mqtt_client, self.config)\n    self._connected = True\n\n    logger.info(\"Successfully connected to MQTT broker\")\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from MQTT broker.</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from MQTT broker.\"\"\"\n    if not self._connected:\n        logger.warning(\"Not connected to MQTT broker\")\n        return\n\n    logger.info(\"Disconnecting from MQTT broker\")\n\n    # Stop listener if running\n    if self.listener and self.listener.is_running:\n        await self.listener.stop_listener()\n\n    await self.mqtt_client.disconnect()\n    self._connected = False\n\n    logger.info(\"Successfully disconnected from MQTT broker\")\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    await self.connect()\n    return self\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    await self.disconnect()\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.subscribe","title":"subscribe  <code>async</code>","text":"<pre><code>subscribe(topic: str, pipeline_name: str, qos: int = 0, execution_mode: str = 'sync') -&gt; None\n</code></pre> <p>Subscribe to MQTT topic and link to FlowerPower pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>MQTT topic pattern to subscribe to</p> required <code>pipeline_name</code> <code>str</code> <p>Name of FlowerPower pipeline to execute</p> required <code>qos</code> <code>int</code> <p>QoS level (0=at most once, 1=at least once, 2=exactly once)</p> <code>0</code> <code>execution_mode</code> <code>str</code> <p>Execution mode (sync, async, mixed)</p> <code>'sync'</code> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def subscribe(\n    self,\n    topic: str,\n    pipeline_name: str,\n    qos: int = 0,\n    execution_mode: str = \"sync\"\n) -&gt; None:\n    \"\"\"\n    Subscribe to MQTT topic and link to FlowerPower pipeline.\n\n    Args:\n        topic: MQTT topic pattern to subscribe to\n        pipeline_name: Name of FlowerPower pipeline to execute\n        qos: QoS level (0=at most once, 1=at least once, 2=exactly once)\n        execution_mode: Execution mode (sync, async, mixed)\n    \"\"\"\n    if not self._connected:\n        raise ConnectionError(\"Not connected to MQTT broker. Call connect() first.\")\n\n    if qos not in [0, 1, 2]:\n        raise SubscriptionError(f\"Invalid QoS level: {qos}. Must be 0, 1, or 2.\")\n\n    if execution_mode not in [\"sync\", \"async\", \"mixed\"]:\n        raise SubscriptionError(\n            f\"Invalid execution mode: {execution_mode}. Must be 'sync', 'async', or 'mixed'.\"\n        )\n\n    # Add to configuration\n    subscription = SubscriptionConfig(\n        topic=topic,\n        pipeline=pipeline_name,\n        qos=qos,\n        execution_mode=execution_mode\n    )\n    self.config.subscriptions.append(subscription)\n\n    # Subscribe via MQTT client\n    await self.mqtt_client.subscribe(topic, pipeline_name, qos, execution_mode)\n\n    logger.info(\n        f\"Subscribed to '{topic}' -&gt; pipeline '{pipeline_name}' \"\n        f\"(QoS {qos}, {execution_mode} mode)\"\n    )\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.subscribe_bulk","title":"subscribe_bulk  <code>async</code>","text":"<pre><code>subscribe_bulk(subscriptions: List[Dict[str, Any]]) -&gt; None\n</code></pre> <p>Subscribe to multiple topics at once.</p> <p>Parameters:</p> Name Type Description Default <code>subscriptions</code> <code>List[Dict[str, Any]]</code> <p>List of subscription dictionaries</p> required Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def subscribe_bulk(self, subscriptions: List[Dict[str, Any]]) -&gt; None:\n    \"\"\"\n    Subscribe to multiple topics at once.\n\n    Args:\n        subscriptions: List of subscription dictionaries\n    \"\"\"\n    for sub in subscriptions:\n        await self.subscribe(\n            topic=sub[\"topic\"],\n            pipeline_name=sub[\"pipeline\"],\n            qos=sub.get(\"qos\", 0),\n            execution_mode=sub.get(\"execution_mode\", \"sync\")\n        )\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.unsubscribe","title":"unsubscribe  <code>async</code>","text":"<pre><code>unsubscribe(topic: str) -&gt; None\n</code></pre> <p>Unsubscribe from MQTT topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>MQTT topic pattern to unsubscribe from</p> required Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def unsubscribe(self, topic: str) -&gt; None:\n    \"\"\"\n    Unsubscribe from MQTT topic.\n\n    Args:\n        topic: MQTT topic pattern to unsubscribe from\n    \"\"\"\n    if not self._connected:\n        raise ConnectionError(\"Not connected to MQTT broker\")\n\n    await self.mqtt_client.unsubscribe(topic)\n\n    # Remove from configuration\n    self.config.subscriptions = [\n        sub for sub in self.config.subscriptions if sub.topic != topic\n    ]\n\n    logger.info(f\"Unsubscribed from '{topic}'\")\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.start_listener","title":"start_listener  <code>async</code>","text":"<pre><code>start_listener(background: bool = False, execution_mode: Optional[str] = None) -&gt; None\n</code></pre> <p>Start listening for MQTT messages.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>bool</code> <p>If True, run listener in background task</p> <code>False</code> <code>execution_mode</code> <code>Optional[str]</code> <p>Override execution mode for all pipelines</p> <code>None</code> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def start_listener(\n    self,\n    background: bool = False,\n    execution_mode: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Start listening for MQTT messages.\n\n    Args:\n        background: If True, run listener in background task\n        execution_mode: Override execution mode for all pipelines\n    \"\"\"\n    if not self._connected:\n        raise ConnectionError(\"Not connected to MQTT broker. Call connect() first.\")\n\n    if not self.listener:\n        raise ConfigurationError(\"Listener not initialized\")\n\n    if not self.config.subscriptions:\n        logger.warning(\"No subscriptions configured\")\n\n    # Override execution mode if specified\n    if execution_mode:\n        for sub in self.config.subscriptions:\n            sub.execution_mode = execution_mode\n\n    logger.info(\n        f\"Starting listener with {len(self.config.subscriptions)} subscriptions \"\n        f\"(background={background})\"\n    )\n\n    try:\n        await self.listener.start_listener(background=background)\n    except KeyboardInterrupt:\n        logger.info(\"Received keyboard interrupt, stopping listener\")\n        await self.stop_listener()\n    except Exception as e:\n        logger.error(f\"Error in listener: {e}\")\n        raise\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.stop_listener","title":"stop_listener  <code>async</code>","text":"<pre><code>stop_listener(timeout: float = 10.0) -&gt; None\n</code></pre> <p>Stop MQTT message listener.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time to wait for graceful shutdown</p> <code>10.0</code> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def stop_listener(self, timeout: float = 10.0) -&gt; None:\n    \"\"\"\n    Stop MQTT message listener.\n\n    Args:\n        timeout: Maximum time to wait for graceful shutdown\n    \"\"\"\n    if not self.listener:\n        logger.warning(\"No listener to stop\")\n        return\n\n    await self.listener.stop_listener(timeout=timeout)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.get_subscriptions","title":"get_subscriptions","text":"<pre><code>get_subscriptions() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get current subscriptions.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of subscription information dictionaries</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>def get_subscriptions(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get current subscriptions.\n\n    Returns:\n        List of subscription information dictionaries\n    \"\"\"\n    if not self._connected:\n        return [sub.to_dict() for sub in self.config.subscriptions]\n\n    subscriptions = []\n    for topic, runtime_sub in self.mqtt_client.get_all_subscriptions().items():\n        sub_info = {\n            \"topic\": runtime_sub.topic,\n            \"pipeline\": runtime_sub.pipeline,\n            \"qos\": runtime_sub.qos,\n            \"execution_mode\": runtime_sub.execution_mode,\n            \"message_count\": runtime_sub.message_count,\n            \"last_message_time\": runtime_sub.last_message_time,\n            \"error_count\": runtime_sub.error_count\n        }\n        subscriptions.append(sub_info)\n\n    return subscriptions\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.get_statistics","title":"get_statistics","text":"<pre><code>get_statistics() -&gt; Dict[str, Any]\n</code></pre> <p>Get plugin statistics.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with current statistics</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>def get_statistics(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get plugin statistics.\n\n    Returns:\n        Dictionary with current statistics\n    \"\"\"\n    stats = {\n        \"connected\": self._connected,\n        \"broker\": f\"{self.config.mqtt.broker}:{self.config.mqtt.port}\",\n        \"subscriptions_count\": len(self.config.subscriptions),\n        \"job_queue_enabled\": self.config.job_queue.enabled\n    }\n\n    if self.listener:\n        stats.update(self.listener.get_statistics())\n\n    return stats\n</code></pre>"},{"location":"api/#flowerpower_mqtt.MQTTPlugin.save_config","title":"save_config","text":"<pre><code>save_config(file_path: Union[str, Path]) -&gt; None\n</code></pre> <p>Save current configuration to YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>Path where to save configuration</p> required Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>def save_config(self, file_path: Union[str, Path]) -&gt; None:\n    \"\"\"\n    Save current configuration to YAML file.\n\n    Args:\n        file_path: Path where to save configuration\n    \"\"\"\n    self.config.to_yaml(Path(file_path))\n    logger.info(f\"Configuration saved to {file_path}\")\n</code></pre>"},{"location":"api/#flowerpower_mqtt-functions","title":"Functions","text":""},{"location":"api/#flowerpower_mqtt.create_simple_mqtt_plugin","title":"create_simple_mqtt_plugin  <code>async</code>","text":"<pre><code>create_simple_mqtt_plugin(broker: str = 'localhost', topic: str = 'test/topic', pipeline: str = 'test_pipeline', qos: int = 0, base_dir: str = '.') -&gt; MQTTPlugin\n</code></pre> <p>Create and configure a simple MQTT plugin instance.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>str</code> <p>MQTT broker hostname</p> <code>'localhost'</code> <code>topic</code> <code>str</code> <p>MQTT topic to subscribe to</p> <code>'test/topic'</code> <code>pipeline</code> <code>str</code> <p>FlowerPower pipeline name</p> <code>'test_pipeline'</code> <code>qos</code> <code>int</code> <p>QoS level</p> <code>0</code> <code>base_dir</code> <code>str</code> <p>FlowerPower project directory</p> <code>'.'</code> <p>Returns:</p> Type Description <code>MQTTPlugin</code> <p>Configured and connected MQTTPlugin instance</p> Source code in <code>src/flowerpower_mqtt/__init__.py</code> <pre><code>async def create_simple_mqtt_plugin(\n    broker: str = \"localhost\",\n    topic: str = \"test/topic\", \n    pipeline: str = \"test_pipeline\",\n    qos: int = 0,\n    base_dir: str = \".\"\n) -&gt; MQTTPlugin:\n    \"\"\"\n    Create and configure a simple MQTT plugin instance.\n\n    Args:\n        broker: MQTT broker hostname\n        topic: MQTT topic to subscribe to\n        pipeline: FlowerPower pipeline name\n        qos: QoS level\n        base_dir: FlowerPower project directory\n\n    Returns:\n        Configured and connected MQTTPlugin instance\n    \"\"\"\n    plugin = MQTTPlugin(broker=broker, base_dir=base_dir)\n    await plugin.connect()\n    await plugin.subscribe(topic, pipeline, qos)\n    return plugin\n</code></pre>"},{"location":"api/#flowerpower_mqtt-modules","title":"Modules","text":""},{"location":"api/#flowerpower_mqtt.cli","title":"cli","text":"<p>Command Line Interface for FlowerPower MQTT Plugin.</p> <p>Provides a comprehensive CLI for managing MQTT connections, subscriptions, and pipeline execution with beautiful rich output.</p>"},{"location":"api/#flowerpower_mqtt.cli-classes","title":"Classes","text":""},{"location":"api/#flowerpower_mqtt.cli-functions","title":"Functions","text":""},{"location":"api/#flowerpower_mqtt.cli.get_config_path","title":"get_config_path","text":"<pre><code>get_config_path() -&gt; Path\n</code></pre> <p>Get configuration file path.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>def get_config_path() -&gt; Path:\n    \"\"\"Get configuration file path.\"\"\"\n    global _config_file\n    if _config_file and _config_file.exists():\n        return _config_file\n\n    # Check common locations\n    candidates = [\n        Path(\"mqtt_config.yml\"),\n        Path(\"config.yml\"),\n        Path(\".flowerpower-mqtt.yml\"),\n        Path.home() / \".config\" / \"flowerpower-mqtt.yml\"\n    ]\n\n    for candidate in candidates:\n        if candidate.exists():\n            return candidate\n\n    # Return default\n    return Path(\"mqtt_config.yml\")\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.load_plugin","title":"load_plugin","text":"<pre><code>load_plugin(config: Optional[Path] = None, broker: Optional[str] = None, port: Optional[int] = None, base_dir: Optional[str] = None, use_job_queue: bool = False, redis_url: Optional[str] = None) -&gt; MQTTPlugin\n</code></pre> <p>Load MQTTPlugin from config or parameters.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>def load_plugin(\n    config: Optional[Path] = None,\n    broker: Optional[str] = None,\n    port: Optional[int] = None,\n    base_dir: Optional[str] = None,\n    use_job_queue: bool = False,\n    redis_url: Optional[str] = None\n) -&gt; MQTTPlugin:\n    \"\"\"Load MQTTPlugin from config or parameters.\"\"\"\n    global _current_plugin, _config_file\n\n    if config and config.exists():\n        _config_file = config\n        _current_plugin = MQTTPlugin.from_config(config)\n        return _current_plugin\n\n    # Create from parameters\n    kwargs = {}\n    if broker:\n        kwargs[\"broker\"] = broker\n    if port:\n        kwargs[\"port\"] = port\n    if base_dir:\n        kwargs[\"base_dir\"] = base_dir\n    if use_job_queue:\n        kwargs[\"use_job_queue\"] = use_job_queue\n    if redis_url:\n        kwargs[\"redis_url\"] = redis_url\n\n    _current_plugin = MQTTPlugin(**kwargs)\n    return _current_plugin\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.handle_async","title":"handle_async","text":"<pre><code>handle_async(coro)\n</code></pre> <p>Handle async functions in CLI commands.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>def handle_async(coro):\n    \"\"\"Handle async functions in CLI commands.\"\"\"\n    try:\n        return asyncio.run(coro)\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Operation cancelled by user[/yellow]\")\n        raise typer.Abort()\n    except Exception as e:\n        console.print(f\"[red]Error: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.connect","title":"connect","text":"<pre><code>connect(broker: str = typer.Option('localhost', '--broker', '-b', help='MQTT broker hostname'), port: int = typer.Option(1883, '--port', '-p', help='MQTT broker port'), config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), base_dir: str = typer.Option('.', '--base-dir', help='FlowerPower project directory'), use_job_queue: bool = typer.Option(False, '--job-queue', help='Enable RQ job queue'), redis_url: str = typer.Option('redis://localhost:6379', '--redis-url', help='Redis URL for job queue'), save_config: bool = typer.Option(False, '--save-config', help='Save configuration to file'))\n</code></pre> <p>Connect to MQTT broker.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command()\ndef connect(\n    broker: str = typer.Option(\"localhost\", \"--broker\", \"-b\", help=\"MQTT broker hostname\"),\n    port: int = typer.Option(1883, \"--port\", \"-p\", help=\"MQTT broker port\"),\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    base_dir: str = typer.Option(\".\", \"--base-dir\", help=\"FlowerPower project directory\"),\n    use_job_queue: bool = typer.Option(False, \"--job-queue\", help=\"Enable RQ job queue\"),\n    redis_url: str = typer.Option(\"redis://localhost:6379\", \"--redis-url\", help=\"Redis URL for job queue\"),\n    save_config: bool = typer.Option(False, \"--save-config\", help=\"Save configuration to file\")\n):\n    \"\"\"Connect to MQTT broker.\"\"\"\n\n    async def _connect():\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console\n        ) as progress:\n            task = progress.add_task(f\"Connecting to {broker}:{port}...\", total=None)\n\n            try:\n                plugin = load_plugin(\n                    config=config,\n                    broker=broker,\n                    port=port,\n                    base_dir=base_dir,\n                    use_job_queue=use_job_queue,\n                    redis_url=redis_url\n                )\n\n                await plugin.connect()\n\n                progress.update(task, description=f\"\u2705 Connected to {broker}:{port}\")\n\n                # Show connection info\n                console.print()\n                info_table = Table(title=\"Connection Information\")\n                info_table.add_column(\"Property\", style=\"bold blue\")\n                info_table.add_column(\"Value\", style=\"green\")\n\n                info_table.add_row(\"Broker\", f\"{broker}:{port}\")\n                info_table.add_row(\"Base Directory\", base_dir)\n                info_table.add_row(\"Job Queue\", \"Enabled\" if use_job_queue else \"Disabled\")\n                if use_job_queue:\n                    info_table.add_row(\"Redis URL\", redis_url)\n\n                console.print(info_table)\n\n                # Save config if requested\n                if save_config:\n                    config_path = get_config_path()\n                    plugin.save_config(config_path)\n                    console.print(f\"\\n[green]Configuration saved to {config_path}[/green]\")\n\n            except Exception as e:\n                progress.update(task, description=f\"\u274c Connection failed: {e}\")\n                raise\n\n    handle_async(_connect())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.subscribe","title":"subscribe","text":"<pre><code>subscribe(topic: str = typer.Argument(..., help='MQTT topic to subscribe to'), pipeline: str = typer.Argument(..., help='FlowerPower pipeline name'), qos: int = typer.Option(0, '--qos', '-q', help='QoS level (0, 1, or 2)'), execution_mode: str = typer.Option('sync', '--mode', '-m', help='Execution mode (sync, async, mixed)'), config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), save_config: bool = typer.Option(False, '--save-config', help='Save subscription to config file'))\n</code></pre> <p>Subscribe to MQTT topic.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command()\ndef subscribe(\n    topic: str = typer.Argument(..., help=\"MQTT topic to subscribe to\"),\n    pipeline: str = typer.Argument(..., help=\"FlowerPower pipeline name\"),\n    qos: int = typer.Option(0, \"--qos\", \"-q\", help=\"QoS level (0, 1, or 2)\"),\n    execution_mode: str = typer.Option(\"sync\", \"--mode\", \"-m\", help=\"Execution mode (sync, async, mixed)\"),\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    save_config: bool = typer.Option(False, \"--save-config\", help=\"Save subscription to config file\")\n):\n    \"\"\"Subscribe to MQTT topic.\"\"\"\n\n    # Validate inputs\n    if qos not in [0, 1, 2]:\n        console.print(\"[red]QoS must be 0, 1, or 2[/red]\")\n        raise typer.Exit(1)\n\n    if execution_mode not in [\"sync\", \"async\", \"mixed\"]:\n        console.print(\"[red]Execution mode must be sync, async, or mixed[/red]\")\n        raise typer.Exit(1)\n\n    async def _subscribe():\n        try:\n            # Load or use existing plugin\n            plugin = _current_plugin or load_plugin(config=config)\n\n            if not plugin.is_connected:\n                console.print(\"[yellow]Plugin not connected. Connecting first...[/yellow]\")\n                await plugin.connect()\n\n            await plugin.subscribe(topic, pipeline, qos, execution_mode)\n\n            # Show subscription info\n            console.print(f\"\\n[green]\u2705 Subscribed to '{topic}' -&gt; '{pipeline}'[/green]\")\n\n            sub_table = Table(title=\"Subscription Details\")\n            sub_table.add_column(\"Property\", style=\"bold blue\")\n            sub_table.add_column(\"Value\", style=\"green\")\n\n            sub_table.add_row(\"Topic\", topic)\n            sub_table.add_row(\"Pipeline\", pipeline)\n            sub_table.add_row(\"QoS Level\", str(qos))\n            sub_table.add_row(\"Execution Mode\", execution_mode)\n\n            console.print(sub_table)\n\n            # Save config if requested\n            if save_config:\n                config_path = get_config_path()\n                plugin.save_config(config_path)\n                console.print(f\"\\n[green]Subscription saved to {config_path}[/green]\")\n\n        except Exception as e:\n            console.print(f\"[red]Subscription failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_subscribe())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.listen","title":"listen","text":"<pre><code>listen(background: bool = typer.Option(False, '--background', '-bg', help='Run listener in background'), execution_mode: Optional[str] = typer.Option(None, '--override-mode', help='Override execution mode for all pipelines'), config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), timeout: Optional[int] = typer.Option(None, '--timeout', help='Stop after specified seconds'))\n</code></pre> <p>Start listening for MQTT messages.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command()\ndef listen(\n    background: bool = typer.Option(False, \"--background\", \"-bg\", help=\"Run listener in background\"),\n    execution_mode: Optional[str] = typer.Option(None, \"--override-mode\", help=\"Override execution mode for all pipelines\"),\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    timeout: Optional[int] = typer.Option(None, \"--timeout\", help=\"Stop after specified seconds\")\n):\n    \"\"\"Start listening for MQTT messages.\"\"\"\n\n    async def _listen():\n        try:\n            # Load or use existing plugin\n            plugin = _current_plugin or load_plugin(config=config)\n\n            if not plugin.is_connected:\n                console.print(\"[yellow]Plugin not connected. Connecting first...[/yellow]\")\n                await plugin.connect()\n\n            subscriptions = plugin.get_subscriptions()\n            if not subscriptions:\n                console.print(\"[yellow]No subscriptions configured. Use 'subscribe' command first.[/yellow]\")\n                return\n\n            # Show listener info\n            console.print(Panel(\n                f\"[bold green]Starting MQTT Listener[/bold green]\\n\\n\"\n                f\"Subscriptions: {len(subscriptions)}\\n\"\n                f\"Background mode: {'Yes' if background else 'No'}\\n\"\n                f\"Execution override: {execution_mode or 'None'}\\n\"\n                f\"Timeout: {timeout or 'None'}\",\n                title=\"Listener Configuration\"\n            ))\n\n            # Show subscriptions table\n            sub_table = Table(title=\"Active Subscriptions\")\n            sub_table.add_column(\"Topic\", style=\"bold blue\")\n            sub_table.add_column(\"Pipeline\", style=\"green\")\n            sub_table.add_column(\"QoS\", style=\"yellow\")\n            sub_table.add_column(\"Mode\", style=\"magenta\")\n\n            for sub in subscriptions:\n                sub_table.add_row(\n                    sub.get(\"topic\", \"\"),\n                    sub.get(\"pipeline\", \"\"),\n                    str(sub.get(\"qos\", 0)),\n                    sub.get(\"execution_mode\", \"sync\")\n                )\n\n            console.print(sub_table)\n            console.print(\"\\n[bold yellow]Press Ctrl+C to stop listener[/bold yellow]\\n\")\n\n            # Start listener\n            if timeout:\n                # Run with timeout\n                try:\n                    await asyncio.wait_for(\n                        plugin.start_listener(background=background, execution_mode=execution_mode),\n                        timeout=timeout\n                    )\n                except asyncio.TimeoutError:\n                    console.print(f\"\\n[yellow]Listener stopped after {timeout} seconds[/yellow]\")\n            else:\n                # Run indefinitely\n                await plugin.start_listener(background=background, execution_mode=execution_mode)\n\n        except KeyboardInterrupt:\n            console.print(\"\\n[yellow]Stopping listener...[/yellow]\")\n            if plugin:\n                await plugin.stop_listener()\n                console.print(\"[green]Listener stopped gracefully[/green]\")\n        except Exception as e:\n            console.print(f\"[red]Listener error: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_listen())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.status","title":"status","text":"<pre><code>status(config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), json_output: bool = typer.Option(False, '--json', help='Output as JSON'))\n</code></pre> <p>Show current plugin status and statistics.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command()\ndef status(\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output as JSON\")\n):\n    \"\"\"Show current plugin status and statistics.\"\"\"\n\n    async def _status():\n        try:\n            # Load or use existing plugin\n            plugin = _current_plugin or load_plugin(config=config)\n\n            # Get statistics\n            stats = plugin.get_statistics()\n            subscriptions = plugin.get_subscriptions()\n\n            if json_output:\n                # JSON output\n                output = {\n                    \"status\": stats,\n                    \"subscriptions\": subscriptions\n                }\n                console.print(json.dumps(output, indent=2, default=str))\n                return\n\n            # Rich formatted output\n            status_table = Table(title=\"Plugin Status\")\n            status_table.add_column(\"Property\", style=\"bold blue\")\n            status_table.add_column(\"Value\", style=\"green\")\n\n            status_table.add_row(\"Connected\", \"\u2705 Yes\" if stats.get(\"connected\", False) else \"\u274c No\")\n            status_table.add_row(\"Broker\", stats.get(\"broker\", \"N/A\"))\n            status_table.add_row(\"Listening\", \"\u2705 Yes\" if stats.get(\"running\", False) else \"\u274c No\")\n            status_table.add_row(\"Runtime\", f\"{stats.get('runtime_seconds', 0):.1f}s\")\n            status_table.add_row(\"Messages\", str(stats.get(\"message_count\", 0)))\n            status_table.add_row(\"Pipelines Executed\", str(stats.get(\"pipeline_count\", 0)))\n            status_table.add_row(\"Errors\", str(stats.get(\"error_count\", 0)))\n            status_table.add_row(\"Subscriptions\", str(len(subscriptions)))\n            status_table.add_row(\"Job Queue\", \"\u2705 Enabled\" if stats.get(\"job_queue_enabled\", False) else \"\u274c Disabled\")\n\n            console.print(status_table)\n\n            if subscriptions:\n                console.print(\"\\n\")\n                sub_table = Table(title=\"Subscription Details\")\n                sub_table.add_column(\"Topic\", style=\"bold blue\")\n                sub_table.add_column(\"Pipeline\", style=\"green\")\n                sub_table.add_column(\"QoS\", style=\"yellow\")\n                sub_table.add_column(\"Mode\", style=\"magenta\")\n                sub_table.add_column(\"Messages\", style=\"cyan\")\n\n                for sub in subscriptions:\n                    sub_table.add_row(\n                        sub.get(\"topic\", \"\"),\n                        sub.get(\"pipeline\", \"\"),\n                        str(sub.get(\"qos\", 0)),\n                        sub.get(\"execution_mode\", \"sync\"),\n                        str(sub.get(\"message_count\", 0))\n                    )\n\n                console.print(sub_table)\n\n        except Exception as e:\n            console.print(f\"[red]Status check failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_status())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.disconnect","title":"disconnect","text":"<pre><code>disconnect(config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'))\n</code></pre> <p>Disconnect from MQTT broker.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command()\ndef disconnect(\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\")\n):\n    \"\"\"Disconnect from MQTT broker.\"\"\"\n\n    async def _disconnect():\n        try:\n            plugin = _current_plugin or load_plugin(config=config)\n\n            if not plugin.is_connected:\n                console.print(\"[yellow]Plugin not connected[/yellow]\")\n                return\n\n            with Progress(\n                SpinnerColumn(),\n                TextColumn(\"[progress.description]{task.description}\"),\n                console=console\n            ) as progress:\n                task = progress.add_task(\"Disconnecting...\", total=None)\n\n                await plugin.disconnect()\n\n                progress.update(task, description=\"\u2705 Disconnected successfully\")\n\n            console.print(\"[green]Disconnected from MQTT broker[/green]\")\n\n        except Exception as e:\n            console.print(f\"[red]Disconnect failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_disconnect())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.config_create","title":"config_create","text":"<pre><code>config_create(output: Path = typer.Option('mqtt_config.yml', '--output', '-o', help='Output configuration file'), interactive: bool = typer.Option(False, '--interactive', '-i', help='Interactive configuration'), with_job_queue: bool = typer.Option(False, '--job-queue', help='Enable job queue configuration'))\n</code></pre> <p>Create a new configuration file.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@config_app.command(\"create\")\ndef config_create(\n    output: Path = typer.Option(\"mqtt_config.yml\", \"--output\", \"-o\", help=\"Output configuration file\"),\n    interactive: bool = typer.Option(False, \"--interactive\", \"-i\", help=\"Interactive configuration\"),\n    with_job_queue: bool = typer.Option(False, \"--job-queue\", help=\"Enable job queue configuration\")\n):\n    \"\"\"Create a new configuration file.\"\"\"\n\n    try:\n        if output.exists() and not Confirm.ask(f\"Configuration file {output} exists. Overwrite?\"):\n            console.print(\"[yellow]Configuration creation cancelled[/yellow]\")\n            return\n\n        config = FlowerPowerMQTTConfig()\n\n        if interactive:\n            console.print(Panel(\"[bold blue]Interactive Configuration Setup[/bold blue]\"))\n\n            # MQTT Configuration\n            console.print(\"\\n[bold]MQTT Broker Configuration[/bold]\")\n            config.mqtt.broker = Prompt.ask(\"MQTT Broker hostname\", default=config.mqtt.broker)\n            config.mqtt.port = int(Prompt.ask(\"MQTT Broker port\", default=str(config.mqtt.port)))\n            config.mqtt.keepalive = int(Prompt.ask(\"Keep alive seconds\", default=str(config.mqtt.keepalive)))\n            config.mqtt.client_id = Prompt.ask(\"Client ID (optional)\", default=config.mqtt.client_id or \"\")\n\n            # Base directory\n            config.base_dir = Prompt.ask(\"FlowerPower base directory\", default=config.base_dir)\n\n            # Job Queue\n            if with_job_queue or Confirm.ask(\"Enable job queue for async processing?\"):\n                config.job_queue.enabled = True\n                config.job_queue.redis_url = Prompt.ask(\"Redis URL\", default=config.job_queue.redis_url)\n                config.job_queue.queue_name = Prompt.ask(\"Queue name\", default=config.job_queue.queue_name)\n                config.job_queue.worker_count = int(Prompt.ask(\"Worker count\", default=str(config.job_queue.worker_count)))\n\n            # Log level\n            log_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"]\n            console.print(f\"Log levels: {', '.join(log_levels)}\")\n            config.log_level = Prompt.ask(\"Log level\", default=config.log_level, choices=log_levels)\n\n        elif with_job_queue:\n            config.job_queue.enabled = True\n\n        # Save configuration\n        config.to_yaml(output)\n\n        console.print(f\"\\n[green]\u2705 Configuration created: {output}[/green]\")\n\n        # Show configuration preview\n        with open(output) as f:\n            config_content = f.read()\n\n        syntax = Syntax(config_content, \"yaml\", theme=\"monokai\", line_numbers=True)\n        console.print(Panel(syntax, title=\"Configuration Preview\"))\n\n    except Exception as e:\n        console.print(f\"[red]Configuration creation failed: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.config_validate","title":"config_validate","text":"<pre><code>config_validate(config_file: Path = typer.Argument(..., help='Configuration file to validate'))\n</code></pre> <p>Validate configuration file.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@config_app.command(\"validate\")\ndef config_validate(\n    config_file: Path = typer.Argument(..., help=\"Configuration file to validate\")\n):\n    \"\"\"Validate configuration file.\"\"\"\n\n    try:\n        if not config_file.exists():\n            console.print(f\"[red]Configuration file not found: {config_file}[/red]\")\n            raise typer.Exit(1)\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console\n        ) as progress:\n            task = progress.add_task(\"Validating configuration...\", total=None)\n\n            # Load and validate configuration\n            config = FlowerPowerMQTTConfig.from_yaml(config_file)\n\n            progress.update(task, description=\"\u2705 Configuration is valid\")\n\n        console.print(f\"[green]\u2705 Configuration file {config_file} is valid[/green]\")\n\n        # Show summary\n        summary_table = Table(title=\"Configuration Summary\")\n        summary_table.add_column(\"Section\", style=\"bold blue\")\n        summary_table.add_column(\"Details\", style=\"green\")\n\n        summary_table.add_row(\"MQTT Broker\", f\"{config.mqtt.broker}:{config.mqtt.port}\")\n        summary_table.add_row(\"Base Directory\", config.base_dir)\n        summary_table.add_row(\"Job Queue\", \"Enabled\" if config.job_queue.enabled else \"Disabled\")\n        summary_table.add_row(\"Subscriptions\", str(len(config.subscriptions)))\n        summary_table.add_row(\"Log Level\", config.log_level)\n\n        console.print(summary_table)\n\n        if config.subscriptions:\n            console.print(\"\\n\")\n            sub_table = Table(title=\"Configured Subscriptions\")\n            sub_table.add_column(\"Topic\", style=\"bold blue\")\n            sub_table.add_column(\"Pipeline\", style=\"green\")\n            sub_table.add_column(\"QoS\", style=\"yellow\")\n            sub_table.add_column(\"Mode\", style=\"magenta\")\n\n            for sub in config.subscriptions:\n                sub_table.add_row(sub.topic, sub.pipeline, str(sub.qos), sub.execution_mode)\n\n            console.print(sub_table)\n\n    except Exception as e:\n        console.print(f\"[red]Configuration validation failed: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.config_show","title":"config_show","text":"<pre><code>config_show(config_file: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), format_output: str = typer.Option('yaml', '--format', help='Output format (yaml, json)'))\n</code></pre> <p>Show current configuration.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@config_app.command(\"show\")\ndef config_show(\n    config_file: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    format_output: str = typer.Option(\"yaml\", \"--format\", help=\"Output format (yaml, json)\")\n):\n    \"\"\"Show current configuration.\"\"\"\n\n    try:\n        config_path = config_file or get_config_path()\n\n        if not config_path.exists():\n            console.print(f\"[yellow]Configuration file not found: {config_path}[/yellow]\")\n            console.print(\"Use 'flowerpower-mqtt config create' to create a new configuration.\")\n            return\n\n        config = FlowerPowerMQTTConfig.from_yaml(config_path)\n\n        if format_output == \"json\":\n            config_dict = config.to_dict()\n            console.print(json.dumps(config_dict, indent=2, default=str))\n        else:\n            # Show YAML content with syntax highlighting\n            with open(config_path) as f:\n                content = f.read()\n\n            syntax = Syntax(content, \"yaml\", theme=\"monokai\", line_numbers=True)\n            console.print(Panel(syntax, title=f\"Configuration: {config_path}\"))\n\n    except Exception as e:\n        console.print(f\"[red]Failed to show configuration: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.config_edit","title":"config_edit","text":"<pre><code>config_edit(config_file: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), editor: Optional[str] = typer.Option(None, '--editor', help='Editor to use (default: $EDITOR)'))\n</code></pre> <p>Edit configuration file.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@config_app.command(\"edit\")\ndef config_edit(\n    config_file: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    editor: Optional[str] = typer.Option(None, \"--editor\", help=\"Editor to use (default: $EDITOR)\")\n):\n    \"\"\"Edit configuration file.\"\"\"\n\n    import os\n    import subprocess\n\n    try:\n        config_path = config_file or get_config_path()\n\n        if not config_path.exists():\n            if Confirm.ask(f\"Configuration file {config_path} does not exist. Create it?\"):\n                # Create basic config\n                config = FlowerPowerMQTTConfig()\n                config.to_yaml(config_path)\n                console.print(f\"[green]Created {config_path}[/green]\")\n            else:\n                return\n\n        # Determine editor\n        editor_cmd = editor or os.environ.get(\"EDITOR\", \"nano\")\n\n        console.print(f\"[blue]Opening {config_path} with {editor_cmd}...[/blue]\")\n\n        # Open editor\n        result = subprocess.run([editor_cmd, str(config_path)])\n\n        if result.returncode == 0:\n            console.print(f\"[green]Configuration file {config_path} updated[/green]\")\n\n            # Validate after editing\n            try:\n                FlowerPowerMQTTConfig.from_yaml(config_path)\n                console.print(\"[green]\u2705 Configuration is valid[/green]\")\n            except Exception as e:\n                console.print(f\"[yellow]\u26a0\ufe0f  Configuration validation warning: {e}[/yellow]\")\n        else:\n            console.print(f\"[yellow]Editor exited with code {result.returncode}[/yellow]\")\n\n    except Exception as e:\n        console.print(f\"[red]Failed to edit configuration: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.monitor","title":"monitor","text":"<pre><code>monitor(config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), interval: int = typer.Option(5, '--interval', '-i', help='Update interval in seconds'), duration: Optional[int] = typer.Option(None, '--duration', '-d', help='Monitor duration in seconds'), json_output: bool = typer.Option(False, '--json', help='Output as JSON'))\n</code></pre> <p>Monitor MQTT plugin in real-time.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command()\ndef monitor(\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    interval: int = typer.Option(5, \"--interval\", \"-i\", help=\"Update interval in seconds\"),\n    duration: Optional[int] = typer.Option(None, \"--duration\", \"-d\", help=\"Monitor duration in seconds\"),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output as JSON\")\n):\n    \"\"\"Monitor MQTT plugin in real-time.\"\"\"\n\n    async def _monitor():\n        try:\n            plugin = _current_plugin or load_plugin(config=config)\n\n            if not plugin.is_connected:\n                console.print(\"[yellow]Plugin not connected. Connect first with 'flowerpower-mqtt connect'[/yellow]\")\n                return\n\n            console.print(Panel(\n                f\"[bold green]Real-time Monitoring[/bold green]\\n\\n\"\n                f\"Update interval: {interval}s\\n\"\n                f\"Duration: {'Unlimited' if not duration else f'{duration}s'}\\n\"\n                f\"Press Ctrl+C to stop\",\n                title=\"Monitor Configuration\"\n            ))\n\n            start_time = asyncio.get_event_loop().time()\n            iteration = 0\n\n            try:\n                while True:\n                    # Check duration limit\n                    if duration and (asyncio.get_event_loop().time() - start_time) &gt;= duration:\n                        console.print(f\"\\n[yellow]Monitoring stopped after {duration} seconds[/yellow]\")\n                        break\n\n                    iteration += 1\n                    stats = plugin.get_statistics()\n                    subscriptions = plugin.get_subscriptions()\n\n                    if json_output:\n                        output = {\n                            \"timestamp\": asyncio.get_event_loop().time(),\n                            \"iteration\": iteration,\n                            \"stats\": stats,\n                            \"subscriptions\": subscriptions\n                        }\n                        console.print(json.dumps(output, indent=2, default=str))\n                    else:\n                        # Clear screen and show updated stats\n                        console.clear()\n                        console.print(f\"[bold blue]Monitor #{iteration}[/bold blue] - {asyncio.get_event_loop().time():.1f}\")\n\n                        # Stats table\n                        stats_table = Table(title=\"Real-time Statistics\")\n                        stats_table.add_column(\"Metric\", style=\"bold blue\")\n                        stats_table.add_column(\"Value\", style=\"green\")\n\n                        stats_table.add_row(\"Connected\", \"\u2705 Yes\" if stats.get(\"connected\", False) else \"\u274c No\")\n                        stats_table.add_row(\"Listening\", \"\u2705 Yes\" if stats.get(\"running\", False) else \"\u274c No\")\n                        stats_table.add_row(\"Runtime\", f\"{stats.get('runtime_seconds', 0):.1f}s\")\n                        stats_table.add_row(\"Messages\", str(stats.get(\"message_count\", 0)))\n                        stats_table.add_row(\"Pipeline Executions\", str(stats.get(\"pipeline_count\", 0)))\n                        stats_table.add_row(\"Errors\", str(stats.get(\"error_count\", 0)))\n\n                        console.print(stats_table)\n\n                        # Subscription activity\n                        if subscriptions:\n                            active_subs = [s for s in subscriptions if s.get('message_count', 0) &gt; 0]\n                            if active_subs:\n                                console.print(\"\\n\")\n                                activity_table = Table(title=\"Active Subscriptions\")\n                                activity_table.add_column(\"Topic\", style=\"bold blue\")\n                                activity_table.add_column(\"Messages\", style=\"yellow\")\n                                activity_table.add_column(\"Pipeline\", style=\"green\")\n\n                                for sub in active_subs:\n                                    activity_table.add_row(\n                                        sub.get(\"topic\", \"\"),\n                                        str(sub.get(\"message_count\", 0)),\n                                        sub.get(\"pipeline\", \"\")\n                                    )\n\n                                console.print(activity_table)\n\n                        console.print(f\"\\n[dim]Press Ctrl+C to stop monitoring...[/dim]\")\n\n                    await asyncio.sleep(interval)\n\n            except KeyboardInterrupt:\n                console.print(\"\\n[yellow]Monitoring stopped by user[/yellow]\")\n\n        except Exception as e:\n            console.print(f\"[red]Monitoring failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_monitor())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.list_subscriptions","title":"list_subscriptions","text":"<pre><code>list_subscriptions(config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), active_only: bool = typer.Option(False, '--active', help='Show only subscriptions with messages'), json_output: bool = typer.Option(False, '--json', help='Output as JSON'))\n</code></pre> <p>List all MQTT subscriptions.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command()\ndef list_subscriptions(\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    active_only: bool = typer.Option(False, \"--active\", help=\"Show only subscriptions with messages\"),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output as JSON\")\n):\n    \"\"\"List all MQTT subscriptions.\"\"\"\n\n    async def _list_subscriptions():\n        try:\n            plugin = _current_plugin or load_plugin(config=config)\n            subscriptions = plugin.get_subscriptions()\n\n            if not subscriptions:\n                console.print(\"[yellow]No subscriptions found[/yellow]\")\n                return\n\n            if active_only:\n                subscriptions = [s for s in subscriptions if s.get('message_count', 0) &gt; 0]\n                if not subscriptions:\n                    console.print(\"[yellow]No active subscriptions found[/yellow]\")\n                    return\n\n            if json_output:\n                console.print(json.dumps(subscriptions, indent=2, default=str))\n                return\n\n            # Rich formatted table\n            sub_table = Table(title=f\"MQTT Subscriptions ({'Active Only' if active_only else 'All'})\")\n            sub_table.add_column(\"Topic\", style=\"bold blue\")\n            sub_table.add_column(\"Pipeline\", style=\"green\")\n            sub_table.add_column(\"QoS\", style=\"yellow\")\n            sub_table.add_column(\"Mode\", style=\"magenta\")\n            sub_table.add_column(\"Messages\", style=\"cyan\")\n            sub_table.add_column(\"Errors\", style=\"red\")\n\n            for sub in subscriptions:\n                sub_table.add_row(\n                    sub.get(\"topic\", \"\"),\n                    sub.get(\"pipeline\", \"\"),\n                    str(sub.get(\"qos\", 0)),\n                    sub.get(\"execution_mode\", \"sync\"),\n                    str(sub.get(\"message_count\", 0)),\n                    str(sub.get(\"error_count\", 0))\n                )\n\n            console.print(sub_table)\n            console.print(f\"\\n[dim]Total subscriptions: {len(subscriptions)}[/dim]\")\n\n        except Exception as e:\n            console.print(f\"[red]Failed to list subscriptions: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_list_subscriptions())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(topic: str = typer.Argument(..., help='Topic to unsubscribe from'), config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), save_config: bool = typer.Option(False, '--save-config', help='Save changes to config file'))\n</code></pre> <p>Unsubscribe from MQTT topic.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@app.command() \ndef unsubscribe(\n    topic: str = typer.Argument(..., help=\"Topic to unsubscribe from\"),\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    save_config: bool = typer.Option(False, \"--save-config\", help=\"Save changes to config file\")\n):\n    \"\"\"Unsubscribe from MQTT topic.\"\"\"\n\n    async def _unsubscribe():\n        try:\n            plugin = _current_plugin or load_plugin(config=config)\n\n            if not plugin.is_connected:\n                console.print(\"[yellow]Plugin not connected. Connect first.[/yellow]\")\n                return\n\n            # Check if topic exists\n            subscriptions = plugin.get_subscriptions()\n            topic_exists = any(sub.get(\"topic\") == topic for sub in subscriptions)\n\n            if not topic_exists:\n                console.print(f\"[yellow]Topic '{topic}' is not subscribed[/yellow]\")\n                return\n\n            await plugin.unsubscribe(topic)\n            console.print(f\"[green]\u2705 Unsubscribed from '{topic}'[/green]\")\n\n            if save_config:\n                config_path = get_config_path()\n                plugin.save_config(config_path)\n                console.print(f\"[green]Changes saved to {config_path}[/green]\")\n\n        except Exception as e:\n            console.print(f\"[red]Unsubscribe failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_unsubscribe())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.jobs_status","title":"jobs_status","text":"<pre><code>jobs_status(config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'), json_output: bool = typer.Option(False, '--json', help='Output as JSON'))\n</code></pre> <p>Show job queue status.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@jobs_app.command(\"status\")\ndef jobs_status(\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\"),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output as JSON\")\n):\n    \"\"\"Show job queue status.\"\"\"\n\n    async def _jobs_status():\n        try:\n            plugin = _current_plugin or load_plugin(config=config)\n\n            if not plugin.config.job_queue.enabled:\n                console.print(\"[yellow]Job queue is not enabled in configuration[/yellow]\")\n                return\n\n            stats = plugin.get_statistics()\n\n            if json_output:\n                console.print(json.dumps({\n                    \"job_queue_enabled\": stats.get(\"job_queue_enabled\", False),\n                    \"job_queue_stats\": stats.get(\"job_queue_stats\", {})\n                }, indent=2))\n                return\n\n            # Rich formatted output\n            queue_table = Table(title=\"Job Queue Status\")\n            queue_table.add_column(\"Property\", style=\"bold blue\")\n            queue_table.add_column(\"Value\", style=\"green\")\n\n            queue_table.add_row(\"Enabled\", \"\u2705 Yes\" if stats.get(\"job_queue_enabled\", False) else \"\u274c No\")\n\n            if \"job_queue_stats\" in stats:\n                job_stats = stats[\"job_queue_stats\"]\n                queue_table.add_row(\"Queue Name\", job_stats.get(\"queue_name\", \"N/A\"))\n                queue_table.add_row(\"Queue Type\", job_stats.get(\"type\", \"N/A\"))\n\n            console.print(queue_table)\n\n        except Exception as e:\n            console.print(f\"[red]Failed to get job queue status: {e}[/red]\")\n            raise typer.Exit(1)\n\n    handle_async(_jobs_status())\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.jobs_worker","title":"jobs_worker","text":"<pre><code>jobs_worker(action: str = typer.Argument(..., help='Worker action (start, stop, status)'), count: int = typer.Option(1, '--count', '-c', help='Number of workers'), config: Optional[Path] = typer.Option(None, '--config', '-c', help='Configuration file'))\n</code></pre> <p>Manage RQ workers.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>@jobs_app.command(\"worker\")\ndef jobs_worker(\n    action: str = typer.Argument(..., help=\"Worker action (start, stop, status)\"),\n    count: int = typer.Option(1, \"--count\", \"-c\", help=\"Number of workers\"),\n    config: Optional[Path] = typer.Option(None, \"--config\", \"-c\", help=\"Configuration file\")\n):\n    \"\"\"Manage RQ workers.\"\"\"\n\n    if action not in [\"start\", \"stop\", \"status\"]:\n        console.print(\"[red]Worker action must be: start, stop, or status[/red]\")\n        raise typer.Exit(1)\n\n    try:\n        plugin = load_plugin(config=config)\n\n        if not plugin.config.job_queue.enabled:\n            console.print(\"[yellow]Job queue is not enabled in configuration[/yellow]\")\n            return\n\n        if action == \"start\":\n            import subprocess\n            redis_url = plugin.config.job_queue.redis_url\n            queue_name = plugin.config.job_queue.queue_name\n\n            console.print(f\"[blue]Starting {count} RQ worker(s) for queue '{queue_name}'...[/blue]\")\n\n            for i in range(count):\n                cmd = f\"rq worker {queue_name} --url {redis_url}\"\n                console.print(f\"[dim]Worker {i+1} command: {cmd}[/dim]\")\n\n                # In a real implementation, you'd start these as background processes\n                console.print(f\"[green]Worker {i+1} started (run manually: {cmd})[/green]\")\n\n            console.print(f\"\\n[bold blue]To start workers manually, run:[/bold blue]\")\n            console.print(f\"rq worker {queue_name} --url {redis_url}\")\n\n        elif action == \"status\":\n            console.print(\"[blue]Checking worker status...[/blue]\")\n\n            try:\n                import subprocess\n                import psutil\n\n                redis_url = plugin.config.job_queue.redis_url\n                queue_name = plugin.config.job_queue.queue_name\n\n                # Check for running RQ worker processes\n                worker_processes = []\n                for proc in psutil.process_iter(['pid', 'name', 'cmdline']):\n                    try:\n                        if proc.info['name'] == 'python' and proc.info['cmdline']:\n                            cmdline = ' '.join(proc.info['cmdline'])\n                            if f'rq worker {queue_name}' in cmdline and redis_url in cmdline:\n                                worker_processes.append(proc.info)\n                    except (psutil.NoSuchProcess, psutil.AccessDenied):\n                        continue\n\n                if worker_processes:\n                    console.print(f\"[green]\u2705 Found {len(worker_processes)} running worker(s)[/green]\")\n\n                    status_table = Table(title=\"Running Workers\")\n                    status_table.add_column(\"PID\", style=\"bold blue\")\n                    status_table.add_column(\"Command\", style=\"green\")\n                    status_table.add_column(\"Status\", style=\"yellow\")\n\n                    for proc in worker_processes:\n                        status_table.add_row(\n                            str(proc['pid']),\n                            ' '.join(proc['cmdline'][:4]) + '...' if len(proc['cmdline']) &gt; 4 else ' '.join(proc['cmdline']),\n                            \"Running\"\n                        )\n\n                    console.print(status_table)\n                else:\n                    console.print(f\"[yellow]No running workers found for queue '{queue_name}'[/yellow]\")\n                    console.print(f\"[dim]To start workers, run: rq worker {queue_name} --url {redis_url}[/dim]\")\n\n            except ImportError:\n                console.print(\"[red]psutil not available. Install with: pip install psutil[/red]\")\n                console.print(\"[yellow]Cannot check worker status without psutil[/yellow]\")\n            except Exception as e:\n                console.print(f\"[red]Error checking worker status: {e}[/red]\")\n\n        elif action == \"stop\":\n            console.print(\"[blue]Stopping workers...[/blue]\")\n\n            try:\n                import subprocess\n                import signal\n                import psutil\n\n                redis_url = plugin.config.job_queue.redis_url\n                queue_name = plugin.config.job_queue.queue_name\n\n                # Find and stop running RQ worker processes\n                stopped_count = 0\n                for proc in psutil.process_iter(['pid', 'name', 'cmdline']):\n                    try:\n                        if proc.info['name'] == 'python' and proc.info['cmdline']:\n                            cmdline = ' '.join(proc.info['cmdline'])\n                            if f'rq worker {queue_name}' in cmdline and redis_url in cmdline:\n                                console.print(f\"[blue]Stopping worker PID {proc.info['pid']}...[/blue]\")\n                                proc.terminate()\n                                stopped_count += 1\n                    except (psutil.NoSuchProcess, psutil.AccessDenied):\n                        continue\n\n                if stopped_count &gt; 0:\n                    console.print(f\"[green]\u2705 Stopped {stopped_count} worker(s)[/green]\")\n                else:\n                    console.print(f\"[yellow]No running workers found for queue '{queue_name}'[/yellow]\")\n\n            except ImportError:\n                console.print(\"[red]psutil not available. Install with: pip install psutil[/red]\")\n                console.print(\"[yellow]Cannot stop workers without psutil[/yellow]\")\n            except Exception as e:\n                console.print(f\"[red]Error stopping workers: {e}[/red]\")\n\n    except Exception as e:\n        console.print(f\"[red]Worker management failed: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Main CLI entry point.</p> Source code in <code>src/flowerpower_mqtt/cli.py</code> <pre><code>def main():\n    \"\"\"Main CLI entry point.\"\"\"\n    app()\n</code></pre>"},{"location":"api/#flowerpower_mqtt.client","title":"client","text":"<p>MQTT client wrapper with QoS support for FlowerPower integration.</p>"},{"location":"api/#flowerpower_mqtt.client-classes","title":"Classes","text":""},{"location":"api/#flowerpower_mqtt.client.MQTTMessage","title":"MQTTMessage  <code>dataclass</code>","text":"<p>Wrapper for MQTT messages with additional metadata.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>@dataclass\nclass MQTTMessage:\n    \"\"\"Wrapper for MQTT messages with additional metadata.\"\"\"\n    topic: str\n    payload: bytes\n    qos: int\n    retain: bool\n    timestamp: float\n\n    @property\n    def payload_str(self) -&gt; str:\n        \"\"\"Get payload as string.\"\"\"\n        return self.payload.decode('utf-8', errors='replace')\n\n    def payload_json(self) -&gt; Dict[str, Any]:\n        \"\"\"Parse payload as JSON.\"\"\"\n        import json\n        return json.loads(self.payload_str)\n</code></pre> Attributes\u00b6 payload_str <code>property</code> \u00b6 <pre><code>payload_str: str\n</code></pre> <p>Get payload as string.</p> Functions\u00b6 payload_json \u00b6 <pre><code>payload_json() -&gt; Dict[str, Any]\n</code></pre> <p>Parse payload as JSON.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>def payload_json(self) -&gt; Dict[str, Any]:\n    \"\"\"Parse payload as JSON.\"\"\"\n    import json\n    return json.loads(self.payload_str)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.client.MQTTClient","title":"MQTTClient","text":"<p>MQTT client wrapper with QoS support and subscription management.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>class MQTTClient:\n    \"\"\"\n    MQTT client wrapper with QoS support and subscription management.\n    \"\"\"\n\n    def __init__(self, config: MQTTConfig):\n        \"\"\"\n        Initialize MQTT client.\n\n        Args:\n            config: MQTT configuration\n        \"\"\"\n        self.config = config\n        self._client: Optional[aiomqtt.Client] = None\n        self._subscriptions: Dict[str, RuntimeSubscription] = {}\n        self._connected = False\n        self._message_handlers: List[Callable[[MQTTMessage], None]] = []\n        self._lock = asyncio.Lock()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        await self.disconnect()\n\n    async def connect(self) -&gt; None:\n        \"\"\"Establish connection to MQTT broker with automatic reconnection.\"\"\"\n        async with self._lock:\n            if self._connected:\n                return\n\n            last_exception = None\n\n            for attempt in range(self.config.reconnect_retries + 1):\n                try:\n                    logger.info(f\"Connecting to MQTT broker at {self.config.broker}:{self.config.port} (attempt {attempt + 1}/{self.config.reconnect_retries + 1})\")\n\n                    # Create aiomqtt client with configuration\n                    self._client = aiomqtt.Client(\n                        hostname=self.config.broker,\n                        port=self.config.port,\n                        keepalive=self.config.keepalive,\n                        client_id=self.config.client_id,\n                        clean_session=self.config.clean_session,\n                        username=self.config.username,\n                        password=self.config.password,\n                    )\n\n                    # Connect using context manager protocol\n                    await self._client.__aenter__()\n                    self._connected = True\n\n                    logger.info(\"Successfully connected to MQTT broker\")\n                    return\n\n                except Exception as e:\n                    last_exception = e\n                    logger.warning(f\"Connection attempt {attempt + 1} failed: {e}\")\n\n                    # Don't wait after the last attempt\n                    if attempt &lt; self.config.reconnect_retries:\n                        # Exponential backoff: delay = base_delay * (2 ^ attempt)\n                        delay = self.config.reconnect_delay * (2 ** attempt)\n                        logger.info(f\"Retrying connection in {delay} seconds...\")\n                        await asyncio.sleep(delay)\n\n            # All retry attempts failed\n            logger.error(f\"Failed to connect to MQTT broker after {self.config.reconnect_retries + 1} attempts\")\n            raise ConnectionError(f\"Failed to connect to MQTT broker after {self.config.reconnect_retries + 1} attempts: {last_exception}\") from last_exception\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from MQTT broker.\"\"\"\n        async with self._lock:\n            if not self._connected or self._client is None:\n                return\n\n            try:\n                logger.info(\"Disconnecting from MQTT broker\")\n                await self._client.__aexit__(None, None, None)\n                self._connected = False\n                self._client = None\n\n                logger.info(\"Successfully disconnected from MQTT broker\")\n\n            except Exception as e:\n                logger.error(f\"Error during disconnect: {e}\")\n                # Don't raise exception during disconnect\n\n    async def subscribe(\n        self, \n        topic: str, \n        pipeline: str, \n        qos: int = 0,\n        execution_mode: str = \"sync\"\n    ) -&gt; None:\n        \"\"\"\n        Subscribe to MQTT topic.\n\n        Args:\n            topic: MQTT topic pattern to subscribe to\n            pipeline: FlowerPower pipeline name to execute\n            qos: QoS level (0, 1, or 2)\n            execution_mode: Pipeline execution mode (sync, async, mixed)\n        \"\"\"\n        if not self._connected or self._client is None:\n            raise ConnectionError(\"Client not connected to broker\")\n\n        if qos not in [0, 1, 2]:\n            raise SubscriptionError(f\"Invalid QoS level: {qos}. Must be 0, 1, or 2\")\n\n        try:\n            logger.info(f\"Subscribing to topic '{topic}' with QoS {qos}\")\n\n            await self._client.subscribe(topic, qos=qos)\n\n            # Store subscription info\n            self._subscriptions[topic] = RuntimeSubscription(\n                topic=topic,\n                pipeline=pipeline,\n                qos=qos,\n                execution_mode=execution_mode\n            )\n\n            logger.info(\n                f\"Successfully subscribed to '{topic}' -&gt; pipeline '{pipeline}'\"\n            )\n\n        except Exception as e:\n            logger.error(f\"Failed to subscribe to topic '{topic}': {e}\")\n            raise SubscriptionError(f\"Failed to subscribe to topic '{topic}': {e}\") from e\n\n    async def unsubscribe(self, topic: str) -&gt; None:\n        \"\"\"\n        Unsubscribe from MQTT topic.\n\n        Args:\n            topic: MQTT topic pattern to unsubscribe from\n        \"\"\"\n        if not self._connected or self._client is None:\n            raise ConnectionError(\"Client not connected to broker\")\n\n        try:\n            logger.info(f\"Unsubscribing from topic '{topic}'\")\n\n            await self._client.unsubscribe(topic)\n\n            # Remove subscription info\n            if topic in self._subscriptions:\n                del self._subscriptions[topic]\n\n            logger.info(f\"Successfully unsubscribed from '{topic}'\")\n\n        except Exception as e:\n            logger.error(f\"Failed to unsubscribe from topic '{topic}': {e}\")\n            raise SubscriptionError(f\"Failed to unsubscribe from topic '{topic}': {e}\") from e\n\n    def add_message_handler(self, handler: Callable[[MQTTMessage], None]) -&gt; None:\n        \"\"\"\n        Add message handler function.\n\n        Args:\n            handler: Function to call when messages arrive\n        \"\"\"\n        self._message_handlers.append(handler)\n\n    def remove_message_handler(self, handler: Callable[[MQTTMessage], None]) -&gt; None:\n        \"\"\"\n        Remove message handler function.\n\n        Args:\n            handler: Handler function to remove\n        \"\"\"\n        if handler in self._message_handlers:\n            self._message_handlers.remove(handler)\n\n    async def listen_for_messages(self) -&gt; None:\n        \"\"\"\n        Listen for incoming MQTT messages and dispatch to handlers.\n        \"\"\"\n        if not self._connected or self._client is None:\n            raise ConnectionError(\"Client not connected to broker\")\n\n        logger.info(\"Starting message listener\")\n\n        try:\n            async for message in self._client.messages:\n                # Update subscription statistics\n                topic_str = str(message.topic)\n                for topic_pattern, sub in self._subscriptions.items():\n                    if message.topic.matches(topic_pattern):\n                        sub.message_count += 1\n                        sub.last_message_time = time.time()\n                        break\n\n                # Create wrapped message\n                mqtt_message = MQTTMessage(\n                    topic=topic_str,\n                    payload=message.payload,\n                    qos=message.qos,\n                    retain=message.retain,\n                    timestamp=time.time()\n                )\n\n                # Dispatch to all handlers\n                for handler in self._message_handlers:\n                    try:\n                        handler(mqtt_message)\n                    except Exception as e:\n                        logger.error(f\"Error in message handler: {e}\")\n\n        except Exception as e:\n            logger.error(f\"Error in message listener: {e}\")\n            raise\n\n    def get_subscription(self, topic: str) -&gt; Optional[RuntimeSubscription]:\n        \"\"\"\n        Get subscription info for a topic.\n\n        Args:\n            topic: Topic pattern\n\n        Returns:\n            RuntimeSubscription or None if not found\n        \"\"\"\n        return self._subscriptions.get(topic)\n\n    def get_all_subscriptions(self) -&gt; Dict[str, RuntimeSubscription]:\n        \"\"\"Get all current subscriptions.\"\"\"\n        return self._subscriptions.copy()\n\n    def find_subscription_for_topic(self, topic: str) -&gt; Optional[RuntimeSubscription]:\n        \"\"\"\n        Find subscription that matches a specific topic.\n\n        Args:\n            topic: Specific topic to match against patterns\n\n        Returns:\n            First matching RuntimeSubscription or None\n        \"\"\"\n        import aiomqtt\n\n        for pattern, subscription in self._subscriptions.items():\n            try:\n                if aiomqtt.Topic(topic).matches(pattern):\n                    return subscription\n            except:\n                # Fallback to simple string comparison\n                if topic == pattern:\n                    return subscription\n\n        return None\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if client is connected.\"\"\"\n        return self._connected\n\n    @property\n    def subscription_count(self) -&gt; int:\n        \"\"\"Get number of active subscriptions.\"\"\"\n        return len(self._subscriptions)\n</code></pre> Attributes\u00b6 is_connected <code>property</code> \u00b6 <pre><code>is_connected: bool\n</code></pre> <p>Check if client is connected.</p> subscription_count <code>property</code> \u00b6 <pre><code>subscription_count: int\n</code></pre> <p>Get number of active subscriptions.</p> Functions\u00b6 __init__ \u00b6 <pre><code>__init__(config: MQTTConfig)\n</code></pre> <p>Initialize MQTT client.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MQTTConfig</code> <p>MQTT configuration</p> required Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>def __init__(self, config: MQTTConfig):\n    \"\"\"\n    Initialize MQTT client.\n\n    Args:\n        config: MQTT configuration\n    \"\"\"\n    self.config = config\n    self._client: Optional[aiomqtt.Client] = None\n    self._subscriptions: Dict[str, RuntimeSubscription] = {}\n    self._connected = False\n    self._message_handlers: List[Callable[[MQTTMessage], None]] = []\n    self._lock = asyncio.Lock()\n</code></pre> __aenter__ <code>async</code> \u00b6 <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    await self.connect()\n    return self\n</code></pre> __aexit__ <code>async</code> \u00b6 <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    await self.disconnect()\n</code></pre> connect <code>async</code> \u00b6 <pre><code>connect() -&gt; None\n</code></pre> <p>Establish connection to MQTT broker with automatic reconnection.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Establish connection to MQTT broker with automatic reconnection.\"\"\"\n    async with self._lock:\n        if self._connected:\n            return\n\n        last_exception = None\n\n        for attempt in range(self.config.reconnect_retries + 1):\n            try:\n                logger.info(f\"Connecting to MQTT broker at {self.config.broker}:{self.config.port} (attempt {attempt + 1}/{self.config.reconnect_retries + 1})\")\n\n                # Create aiomqtt client with configuration\n                self._client = aiomqtt.Client(\n                    hostname=self.config.broker,\n                    port=self.config.port,\n                    keepalive=self.config.keepalive,\n                    client_id=self.config.client_id,\n                    clean_session=self.config.clean_session,\n                    username=self.config.username,\n                    password=self.config.password,\n                )\n\n                # Connect using context manager protocol\n                await self._client.__aenter__()\n                self._connected = True\n\n                logger.info(\"Successfully connected to MQTT broker\")\n                return\n\n            except Exception as e:\n                last_exception = e\n                logger.warning(f\"Connection attempt {attempt + 1} failed: {e}\")\n\n                # Don't wait after the last attempt\n                if attempt &lt; self.config.reconnect_retries:\n                    # Exponential backoff: delay = base_delay * (2 ^ attempt)\n                    delay = self.config.reconnect_delay * (2 ** attempt)\n                    logger.info(f\"Retrying connection in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n\n        # All retry attempts failed\n        logger.error(f\"Failed to connect to MQTT broker after {self.config.reconnect_retries + 1} attempts\")\n        raise ConnectionError(f\"Failed to connect to MQTT broker after {self.config.reconnect_retries + 1} attempts: {last_exception}\") from last_exception\n</code></pre> disconnect <code>async</code> \u00b6 <pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from MQTT broker.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from MQTT broker.\"\"\"\n    async with self._lock:\n        if not self._connected or self._client is None:\n            return\n\n        try:\n            logger.info(\"Disconnecting from MQTT broker\")\n            await self._client.__aexit__(None, None, None)\n            self._connected = False\n            self._client = None\n\n            logger.info(\"Successfully disconnected from MQTT broker\")\n\n        except Exception as e:\n            logger.error(f\"Error during disconnect: {e}\")\n</code></pre> subscribe <code>async</code> \u00b6 <pre><code>subscribe(topic: str, pipeline: str, qos: int = 0, execution_mode: str = 'sync') -&gt; None\n</code></pre> <p>Subscribe to MQTT topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>MQTT topic pattern to subscribe to</p> required <code>pipeline</code> <code>str</code> <p>FlowerPower pipeline name to execute</p> required <code>qos</code> <code>int</code> <p>QoS level (0, 1, or 2)</p> <code>0</code> <code>execution_mode</code> <code>str</code> <p>Pipeline execution mode (sync, async, mixed)</p> <code>'sync'</code> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>async def subscribe(\n    self, \n    topic: str, \n    pipeline: str, \n    qos: int = 0,\n    execution_mode: str = \"sync\"\n) -&gt; None:\n    \"\"\"\n    Subscribe to MQTT topic.\n\n    Args:\n        topic: MQTT topic pattern to subscribe to\n        pipeline: FlowerPower pipeline name to execute\n        qos: QoS level (0, 1, or 2)\n        execution_mode: Pipeline execution mode (sync, async, mixed)\n    \"\"\"\n    if not self._connected or self._client is None:\n        raise ConnectionError(\"Client not connected to broker\")\n\n    if qos not in [0, 1, 2]:\n        raise SubscriptionError(f\"Invalid QoS level: {qos}. Must be 0, 1, or 2\")\n\n    try:\n        logger.info(f\"Subscribing to topic '{topic}' with QoS {qos}\")\n\n        await self._client.subscribe(topic, qos=qos)\n\n        # Store subscription info\n        self._subscriptions[topic] = RuntimeSubscription(\n            topic=topic,\n            pipeline=pipeline,\n            qos=qos,\n            execution_mode=execution_mode\n        )\n\n        logger.info(\n            f\"Successfully subscribed to '{topic}' -&gt; pipeline '{pipeline}'\"\n        )\n\n    except Exception as e:\n        logger.error(f\"Failed to subscribe to topic '{topic}': {e}\")\n        raise SubscriptionError(f\"Failed to subscribe to topic '{topic}': {e}\") from e\n</code></pre> unsubscribe <code>async</code> \u00b6 <pre><code>unsubscribe(topic: str) -&gt; None\n</code></pre> <p>Unsubscribe from MQTT topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>MQTT topic pattern to unsubscribe from</p> required Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>async def unsubscribe(self, topic: str) -&gt; None:\n    \"\"\"\n    Unsubscribe from MQTT topic.\n\n    Args:\n        topic: MQTT topic pattern to unsubscribe from\n    \"\"\"\n    if not self._connected or self._client is None:\n        raise ConnectionError(\"Client not connected to broker\")\n\n    try:\n        logger.info(f\"Unsubscribing from topic '{topic}'\")\n\n        await self._client.unsubscribe(topic)\n\n        # Remove subscription info\n        if topic in self._subscriptions:\n            del self._subscriptions[topic]\n\n        logger.info(f\"Successfully unsubscribed from '{topic}'\")\n\n    except Exception as e:\n        logger.error(f\"Failed to unsubscribe from topic '{topic}': {e}\")\n        raise SubscriptionError(f\"Failed to unsubscribe from topic '{topic}': {e}\") from e\n</code></pre> add_message_handler \u00b6 <pre><code>add_message_handler(handler: Callable[[MQTTMessage], None]) -&gt; None\n</code></pre> <p>Add message handler function.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[MQTTMessage], None]</code> <p>Function to call when messages arrive</p> required Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>def add_message_handler(self, handler: Callable[[MQTTMessage], None]) -&gt; None:\n    \"\"\"\n    Add message handler function.\n\n    Args:\n        handler: Function to call when messages arrive\n    \"\"\"\n    self._message_handlers.append(handler)\n</code></pre> remove_message_handler \u00b6 <pre><code>remove_message_handler(handler: Callable[[MQTTMessage], None]) -&gt; None\n</code></pre> <p>Remove message handler function.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[MQTTMessage], None]</code> <p>Handler function to remove</p> required Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>def remove_message_handler(self, handler: Callable[[MQTTMessage], None]) -&gt; None:\n    \"\"\"\n    Remove message handler function.\n\n    Args:\n        handler: Handler function to remove\n    \"\"\"\n    if handler in self._message_handlers:\n        self._message_handlers.remove(handler)\n</code></pre> listen_for_messages <code>async</code> \u00b6 <pre><code>listen_for_messages() -&gt; None\n</code></pre> <p>Listen for incoming MQTT messages and dispatch to handlers.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>async def listen_for_messages(self) -&gt; None:\n    \"\"\"\n    Listen for incoming MQTT messages and dispatch to handlers.\n    \"\"\"\n    if not self._connected or self._client is None:\n        raise ConnectionError(\"Client not connected to broker\")\n\n    logger.info(\"Starting message listener\")\n\n    try:\n        async for message in self._client.messages:\n            # Update subscription statistics\n            topic_str = str(message.topic)\n            for topic_pattern, sub in self._subscriptions.items():\n                if message.topic.matches(topic_pattern):\n                    sub.message_count += 1\n                    sub.last_message_time = time.time()\n                    break\n\n            # Create wrapped message\n            mqtt_message = MQTTMessage(\n                topic=topic_str,\n                payload=message.payload,\n                qos=message.qos,\n                retain=message.retain,\n                timestamp=time.time()\n            )\n\n            # Dispatch to all handlers\n            for handler in self._message_handlers:\n                try:\n                    handler(mqtt_message)\n                except Exception as e:\n                    logger.error(f\"Error in message handler: {e}\")\n\n    except Exception as e:\n        logger.error(f\"Error in message listener: {e}\")\n        raise\n</code></pre> get_subscription \u00b6 <pre><code>get_subscription(topic: str) -&gt; Optional[RuntimeSubscription]\n</code></pre> <p>Get subscription info for a topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Topic pattern</p> required <p>Returns:</p> Type Description <code>Optional[RuntimeSubscription]</code> <p>RuntimeSubscription or None if not found</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>def get_subscription(self, topic: str) -&gt; Optional[RuntimeSubscription]:\n    \"\"\"\n    Get subscription info for a topic.\n\n    Args:\n        topic: Topic pattern\n\n    Returns:\n        RuntimeSubscription or None if not found\n    \"\"\"\n    return self._subscriptions.get(topic)\n</code></pre> get_all_subscriptions \u00b6 <pre><code>get_all_subscriptions() -&gt; Dict[str, RuntimeSubscription]\n</code></pre> <p>Get all current subscriptions.</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>def get_all_subscriptions(self) -&gt; Dict[str, RuntimeSubscription]:\n    \"\"\"Get all current subscriptions.\"\"\"\n    return self._subscriptions.copy()\n</code></pre> find_subscription_for_topic \u00b6 <pre><code>find_subscription_for_topic(topic: str) -&gt; Optional[RuntimeSubscription]\n</code></pre> <p>Find subscription that matches a specific topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Specific topic to match against patterns</p> required <p>Returns:</p> Type Description <code>Optional[RuntimeSubscription]</code> <p>First matching RuntimeSubscription or None</p> Source code in <code>src/flowerpower_mqtt/client.py</code> <pre><code>def find_subscription_for_topic(self, topic: str) -&gt; Optional[RuntimeSubscription]:\n    \"\"\"\n    Find subscription that matches a specific topic.\n\n    Args:\n        topic: Specific topic to match against patterns\n\n    Returns:\n        First matching RuntimeSubscription or None\n    \"\"\"\n    import aiomqtt\n\n    for pattern, subscription in self._subscriptions.items():\n        try:\n            if aiomqtt.Topic(topic).matches(pattern):\n                return subscription\n        except:\n            # Fallback to simple string comparison\n            if topic == pattern:\n                return subscription\n\n    return None\n</code></pre>"},{"location":"api/#flowerpower_mqtt.config","title":"config","text":"<p>Configuration management for FlowerPower MQTT plugin.</p>"},{"location":"api/#flowerpower_mqtt.config-classes","title":"Classes","text":""},{"location":"api/#flowerpower_mqtt.config.MQTTConfig","title":"MQTTConfig","text":"<p>               Bases: <code>Struct</code></p> <p>MQTT broker configuration.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class MQTTConfig(Struct):\n    \"\"\"MQTT broker configuration.\"\"\"\n    broker: str = \"localhost\"\n    port: int = 1883\n    keepalive: int = 60\n    client_id: Optional[str] = None\n    clean_session: bool = True\n    username: Optional[str] = None\n    password: Optional[str] = None\n    reconnect_retries: int = 5\n    reconnect_delay: int = 5\n</code></pre>"},{"location":"api/#flowerpower_mqtt.config.JobQueueConfig","title":"JobQueueConfig","text":"<p>               Bases: <code>Struct</code></p> <p>Job queue configuration.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class JobQueueConfig(Struct):\n    \"\"\"Job queue configuration.\"\"\"\n    enabled: bool = False\n    type: str = \"rq\"\n    redis_url: str = \"redis://localhost:6379\"\n    queue_name: str = \"mqtt_pipelines\"\n    worker_count: int = 4\n    max_retries: int = 3\n</code></pre>"},{"location":"api/#flowerpower_mqtt.config.SubscriptionConfig","title":"SubscriptionConfig","text":"<p>               Bases: <code>Struct</code></p> <p>Individual subscription configuration.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class SubscriptionConfig(Struct):\n    \"\"\"Individual subscription configuration.\"\"\"\n    topic: str\n    pipeline: str\n    qos: Annotated[int, Meta(extra=_validate_qos)] = 0\n    execution_mode: Annotated[str, Meta(extra=_validate_execution_mode)] = \"sync\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for compatibility.\"\"\"\n        return msgspec.to_builtins(self)\n</code></pre> Functions\u00b6 to_dict \u00b6 <pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert to dictionary for compatibility.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for compatibility.\"\"\"\n    return msgspec.to_builtins(self)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.config.FlowerPowerMQTTConfig","title":"FlowerPowerMQTTConfig","text":"<p>               Bases: <code>Struct</code></p> <p>Main configuration for FlowerPower MQTT plugin.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>class FlowerPowerMQTTConfig(Struct):\n    \"\"\"Main configuration for FlowerPower MQTT plugin.\"\"\"\n    mqtt: MQTTConfig = MQTTConfig()\n    job_queue: JobQueueConfig = JobQueueConfig()\n    subscriptions: List[SubscriptionConfig] = msgspec.field(default_factory=list)\n    base_dir: str = \".\"\n    log_level: str = \"INFO\"\n\n    @classmethod\n    def from_yaml(cls, file_path: Path) -&gt; \"FlowerPowerMQTTConfig\":\n        \"\"\"Load configuration from YAML file.\"\"\"\n        if not file_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {file_path}\")\n\n        with open(file_path, 'r') as f:\n            data = yaml.safe_load(f)\n\n        # Convert nested dictionaries to proper types\n        return msgspec.convert(data, cls)\n\n    def to_yaml(self, file_path: Path) -&gt; None:\n        \"\"\"Save configuration to YAML file.\"\"\"\n        # Convert struct to dictionary\n        data = msgspec.to_builtins(self)\n\n        with open(file_path, 'w') as f:\n            yaml.dump(data, f, default_flow_style=False, indent=2)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for compatibility.\"\"\"\n        return msgspec.to_builtins(self)\n</code></pre> Functions\u00b6 from_yaml <code>classmethod</code> \u00b6 <pre><code>from_yaml(file_path: Path) -&gt; FlowerPowerMQTTConfig\n</code></pre> <p>Load configuration from YAML file.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>@classmethod\ndef from_yaml(cls, file_path: Path) -&gt; \"FlowerPowerMQTTConfig\":\n    \"\"\"Load configuration from YAML file.\"\"\"\n    if not file_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {file_path}\")\n\n    with open(file_path, 'r') as f:\n        data = yaml.safe_load(f)\n\n    # Convert nested dictionaries to proper types\n    return msgspec.convert(data, cls)\n</code></pre> to_yaml \u00b6 <pre><code>to_yaml(file_path: Path) -&gt; None\n</code></pre> <p>Save configuration to YAML file.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>def to_yaml(self, file_path: Path) -&gt; None:\n    \"\"\"Save configuration to YAML file.\"\"\"\n    # Convert struct to dictionary\n    data = msgspec.to_builtins(self)\n\n    with open(file_path, 'w') as f:\n        yaml.dump(data, f, default_flow_style=False, indent=2)\n</code></pre> to_dict \u00b6 <pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert to dictionary for compatibility.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for compatibility.\"\"\"\n    return msgspec.to_builtins(self)\n</code></pre>"},{"location":"api/#flowerpower_mqtt.config.RuntimeSubscription","title":"RuntimeSubscription  <code>dataclass</code>","text":"<p>Runtime subscription data with additional metadata.</p> Source code in <code>src/flowerpower_mqtt/config.py</code> <pre><code>@dataclass\nclass RuntimeSubscription:\n    \"\"\"Runtime subscription data with additional metadata.\"\"\"\n    topic: str\n    pipeline: str\n    qos: int = 0\n    execution_mode: str = \"sync\"\n    message_count: int = 0\n    last_message_time: Optional[float] = None\n    error_count: int = 0\n</code></pre>"},{"location":"api/#flowerpower_mqtt.exceptions","title":"exceptions","text":"<p>Custom exceptions for FlowerPower MQTT plugin.</p>"},{"location":"api/#flowerpower_mqtt.exceptions-classes","title":"Classes","text":""},{"location":"api/#flowerpower_mqtt.exceptions.FlowerPowerMQTTError","title":"FlowerPowerMQTTError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for FlowerPower MQTT plugin.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class FlowerPowerMQTTError(Exception):\n    \"\"\"Base exception for FlowerPower MQTT plugin.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.exceptions.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when MQTT connection fails.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class ConnectionError(FlowerPowerMQTTError):\n    \"\"\"Raised when MQTT connection fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.exceptions.SubscriptionError","title":"SubscriptionError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when MQTT subscription fails.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class SubscriptionError(FlowerPowerMQTTError):\n    \"\"\"Raised when MQTT subscription fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.exceptions.PipelineExecutionError","title":"PipelineExecutionError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when pipeline execution fails.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class PipelineExecutionError(FlowerPowerMQTTError):\n    \"\"\"Raised when pipeline execution fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.exceptions.JobQueueError","title":"JobQueueError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when job queue operations fail.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class JobQueueError(FlowerPowerMQTTError):\n    \"\"\"Raised when job queue operations fail.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.exceptions.ConfigurationError","title":"ConfigurationError","text":"<p>               Bases: <code>FlowerPowerMQTTError</code></p> <p>Raised when configuration is invalid.</p> Source code in <code>src/flowerpower_mqtt/exceptions.py</code> <pre><code>class ConfigurationError(FlowerPowerMQTTError):\n    \"\"\"Raised when configuration is invalid.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#flowerpower_mqtt.job_handler","title":"job_handler","text":"<p>RQ job handler functions for pipeline execution.</p>"},{"location":"api/#flowerpower_mqtt.job_handler-classes","title":"Classes","text":""},{"location":"api/#flowerpower_mqtt.job_handler-functions","title":"Functions","text":""},{"location":"api/#flowerpower_mqtt.job_handler.execute_pipeline_job","title":"execute_pipeline_job","text":"<pre><code>execute_pipeline_job(pipeline_name: str, message_data: Dict[str, Any], base_dir: str, topic: str, qos: int, execution_metadata: Optional[Dict[str, Any]] = None) -&gt; Dict[str, Any]\n</code></pre> <p>RQ job function for executing FlowerPower pipelines.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline_name</code> <code>str</code> <p>Name of the pipeline to execute</p> required <code>message_data</code> <code>Dict[str, Any]</code> <p>MQTT message data to pass as pipeline input</p> required <code>base_dir</code> <code>str</code> <p>FlowerPower project base directory</p> required <code>topic</code> <code>str</code> <p>MQTT topic the message came from</p> required <code>qos</code> <code>int</code> <p>QoS level of the message</p> required <code>execution_metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional metadata for execution</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing execution status and results</p> Source code in <code>src/flowerpower_mqtt/job_handler.py</code> <pre><code>def execute_pipeline_job(\n    pipeline_name: str, \n    message_data: Dict[str, Any], \n    base_dir: str,\n    topic: str,\n    qos: int,\n    execution_metadata: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    RQ job function for executing FlowerPower pipelines.\n\n    Args:\n        pipeline_name: Name of the pipeline to execute\n        message_data: MQTT message data to pass as pipeline input\n        base_dir: FlowerPower project base directory\n        topic: MQTT topic the message came from\n        qos: QoS level of the message\n        execution_metadata: Additional metadata for execution\n\n    Returns:\n        Dict containing execution status and results\n    \"\"\"\n    start_time = datetime.now()\n\n    try:\n        logger.info(\n            f\"Starting pipeline execution: {pipeline_name} \"\n            f\"for topic {topic} (QoS {qos})\"\n        )\n\n        # Initialize pipeline manager\n        pm = PipelineManager(base_dir=base_dir)\n\n        # Prepare pipeline inputs\n        pipeline_inputs = {\n            \"mqtt_message\": message_data,\n            \"mqtt_topic\": topic,\n            \"mqtt_qos\": qos,\n            \"execution_timestamp\": start_time.isoformat(),\n            **(execution_metadata or {})\n        }\n\n        # Execute the pipeline\n        result = pm.run(\n            name=pipeline_name,\n            inputs=pipeline_inputs\n        )\n\n        execution_time = (datetime.now() - start_time).total_seconds()\n\n        success_result = {\n            \"status\": \"success\",\n            \"pipeline_name\": pipeline_name,\n            \"topic\": topic,\n            \"qos\": qos,\n            \"execution_time\": execution_time,\n            \"start_time\": start_time.isoformat(),\n            \"result\": result\n        }\n\n        logger.info(\n            f\"Pipeline {pipeline_name} completed successfully \"\n            f\"in {execution_time:.2f}s\"\n        )\n\n        return success_result\n\n    except Exception as e:\n        execution_time = (datetime.now() - start_time).total_seconds()\n\n        error_result = {\n            \"status\": \"error\",\n            \"pipeline_name\": pipeline_name,\n            \"topic\": topic,\n            \"qos\": qos,\n            \"execution_time\": execution_time,\n            \"start_time\": start_time.isoformat(),\n            \"error\": str(e),\n            \"error_type\": type(e).__name__\n        }\n\n        logger.error(\n            f\"Pipeline {pipeline_name} failed after {execution_time:.2f}s: {e}\"\n        )\n\n        # Re-raise for RQ to handle retries\n        raise PipelineExecutionError(\n            f\"Pipeline '{pipeline_name}' execution failed: {e}\"\n        ) from e\n</code></pre>"},{"location":"api/#flowerpower_mqtt.job_handler.get_job_status","title":"get_job_status","text":"<pre><code>get_job_status(job_id: str, job_queue_manager: JobQueueManager) -&gt; Dict[str, Any]\n</code></pre> <p>Get the status of a job.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>RQ job ID</p> required <code>job_queue_manager</code> <code>JobQueueManager</code> <p>JobQueueManager instance</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing job status information</p> Source code in <code>src/flowerpower_mqtt/job_handler.py</code> <pre><code>def get_job_status(job_id: str, job_queue_manager: JobQueueManager) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the status of a job.\n\n    Args:\n        job_id: RQ job ID\n        job_queue_manager: JobQueueManager instance\n\n    Returns:\n        Dict containing job status information\n    \"\"\"\n    try:\n        job = job_queue_manager.get_job(job_id)\n        if job is None:\n            return {\"status\": \"not_found\", \"job_id\": job_id}\n\n        return {\n            \"status\": job.get_status(),\n            \"job_id\": job_id,\n            \"created_at\": job.created_at.isoformat() if job.created_at else None,\n            \"started_at\": job.started_at.isoformat() if job.started_at else None,\n            \"ended_at\": job.ended_at.isoformat() if job.ended_at else None,\n            \"result\": job.result if job.is_finished else None,\n            \"exc_info\": job.exc_info if job.is_failed else None\n        }\n    except Exception as e:\n        logger.error(f\"Error getting job status for {job_id}: {e}\")\n        return {\n            \"status\": \"error\",\n            \"job_id\": job_id,\n            \"error\": str(e)\n        }\n</code></pre>"},{"location":"api/#flowerpower_mqtt.job_handler.cleanup_completed_jobs","title":"cleanup_completed_jobs","text":"<pre><code>cleanup_completed_jobs(job_queue_manager: JobQueueManager, max_age_hours: int = 24) -&gt; Dict[str, int]\n</code></pre> <p>Clean up completed jobs older than specified age.</p> <p>Parameters:</p> Name Type Description Default <code>job_queue_manager</code> <code>JobQueueManager</code> <p>JobQueueManager instance</p> required <code>max_age_hours</code> <code>int</code> <p>Maximum age of jobs to keep</p> <code>24</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict with cleanup statistics</p> Source code in <code>src/flowerpower_mqtt/job_handler.py</code> <pre><code>def cleanup_completed_jobs(\n    job_queue_manager: JobQueueManager,\n    max_age_hours: int = 24\n) -&gt; Dict[str, int]:\n    \"\"\"\n    Clean up completed jobs older than specified age.\n\n    Args:\n        job_queue_manager: JobQueueManager instance\n        max_age_hours: Maximum age of jobs to keep\n\n    Returns:\n        Dict with cleanup statistics\n    \"\"\"\n    try:\n        # This would depend on the specific JobQueueManager implementation\n        # For now, return a placeholder\n        logger.info(f\"Job cleanup requested for jobs older than {max_age_hours} hours\")\n        return {\"cleaned_count\": 0, \"error_count\": 0}\n    except Exception as e:\n        logger.error(f\"Error during job cleanup: {e}\")\n        return {\"cleaned_count\": 0, \"error_count\": 1}\n</code></pre>"},{"location":"api/#flowerpower_mqtt.listener","title":"listener","text":"<p>MQTT listener with FlowerPower pipeline execution and job queue integration.</p>"},{"location":"api/#flowerpower_mqtt.listener-classes","title":"Classes","text":""},{"location":"api/#flowerpower_mqtt.listener.MQTTListener","title":"MQTTListener","text":"<p>MQTT listener that processes messages and executes FlowerPower pipelines. Supports both synchronous and asynchronous execution via RQ job queue.</p> Source code in <code>src/flowerpower_mqtt/listener.py</code> <pre><code>class MQTTListener:\n    \"\"\"\n    MQTT listener that processes messages and executes FlowerPower pipelines.\n    Supports both synchronous and asynchronous execution via RQ job queue.\n    \"\"\"\n\n    def __init__(\n        self, \n        mqtt_client: MQTTClient,\n        config: FlowerPowerMQTTConfig\n    ):\n        \"\"\"\n        Initialize MQTT listener.\n\n        Args:\n            mqtt_client: Connected MQTT client instance\n            config: FlowerPower MQTT configuration\n        \"\"\"\n        self.mqtt_client = mqtt_client\n        self.config = config\n\n        # FlowerPower managers\n        self.pipeline_manager = PipelineManager(base_dir=config.base_dir)\n        self.job_queue_manager: Optional[JobQueueManager] = None\n\n        # State management\n        self._running = False\n        self._listener_task: Optional[asyncio.Task] = None\n        self._shutdown_event = asyncio.Event()\n\n        # Statistics\n        self._message_count = 0\n        self._pipeline_count = 0\n        self._error_count = 0\n        self._start_time: Optional[datetime] = None\n\n        # Initialize job queue if enabled\n        if config.job_queue.enabled:\n            self._init_job_queue()\n\n        # Register message handler\n        self.mqtt_client.add_message_handler(self._handle_message)\n\n    def _init_job_queue(self) -&gt; None:\n        \"\"\"Initialize job queue manager.\"\"\"\n        try:\n            jq_config = self.config.job_queue\n\n            logger.info(f\"Initializing job queue: {jq_config.type}\")\n\n            self.job_queue_manager = JobQueueManager(\n                type=jq_config.type,\n                name=jq_config.queue_name,\n                base_dir=self.config.base_dir\n            )\n\n            logger.info(\"Job queue manager initialized successfully\")\n\n        except Exception as e:\n            logger.error(f\"Failed to initialize job queue: {e}\")\n            raise JobQueueError(f\"Failed to initialize job queue: {e}\") from e\n\n    def _handle_message(self, message: MQTTMessage) -&gt; None:\n        \"\"\"\n        Handle incoming MQTT message.\n\n        Args:\n            message: MQTT message to process\n        \"\"\"\n        self._message_count += 1\n\n        try:\n            # Find matching subscription\n            subscription = self.mqtt_client.find_subscription_for_topic(message.topic)\n            if not subscription:\n                logger.warning(f\"No subscription found for topic: {message.topic}\")\n                return\n\n            logger.info(\n                f\"Processing message from topic '{message.topic}' \"\n                f\"-&gt; pipeline '{subscription.pipeline}' (QoS {message.qos})\"\n            )\n\n            # Parse message payload\n            message_data = self._parse_message_payload(message)\n\n            # Determine execution mode\n            execution_mode = self._determine_execution_mode(subscription, message)\n\n            # Execute pipeline based on mode\n            if execution_mode == \"sync\":\n                self._execute_pipeline_sync(subscription.pipeline, message_data, message)\n            elif execution_mode == \"async\":\n                self._execute_pipeline_async(subscription.pipeline, message_data, message)\n            else:\n                logger.error(f\"Unknown execution mode: {execution_mode}\")\n                self._error_count += 1\n\n        except Exception as e:\n            logger.error(f\"Error handling message from topic '{message.topic}': {e}\")\n            self._error_count += 1\n\n    def _parse_message_payload(self, message: MQTTMessage) -&gt; Dict[str, Any]:\n        \"\"\"\n        Parse MQTT message payload.\n\n        Args:\n            message: MQTT message\n\n        Returns:\n            Parsed payload data\n        \"\"\"\n        try:\n            # Try to parse as JSON\n            return message.payload_json()\n        except json.JSONDecodeError:\n            # Fallback to string payload\n            return {\n                \"raw_payload\": message.payload_str,\n                \"payload_bytes\": message.payload\n            }\n\n    def _determine_execution_mode(self, subscription, message: MQTTMessage) -&gt; str:\n        \"\"\"\n        Determine execution mode based on configuration and message.\n\n        Args:\n            subscription: Runtime subscription info\n            message: MQTT message\n\n        Returns:\n            Execution mode (\"sync\" or \"async\")\n        \"\"\"\n        if not self.config.job_queue.enabled:\n            return \"sync\"\n\n        mode = subscription.execution_mode\n\n        if mode == \"mixed\":\n            # QoS 2 messages are executed synchronously, others async\n            return \"sync\" if message.qos &gt;= 2 else \"async\"\n\n        return mode\n\n    def _execute_pipeline_sync(\n        self, \n        pipeline_name: str, \n        message_data: Dict[str, Any],\n        message: MQTTMessage\n    ) -&gt; None:\n        \"\"\"\n        Execute pipeline synchronously.\n\n        Args:\n            pipeline_name: Name of pipeline to execute\n            message_data: Parsed message data\n            message: Original MQTT message\n        \"\"\"\n        try:\n            start_time = datetime.now()\n\n            # Prepare pipeline inputs\n            pipeline_inputs = {\n                \"mqtt_message\": message_data,\n                \"mqtt_topic\": message.topic,\n                \"mqtt_qos\": message.qos,\n                \"execution_timestamp\": start_time.isoformat(),\n                \"execution_mode\": \"sync\"\n            }\n\n            # Execute pipeline\n            result = self.pipeline_manager.run(\n                name=pipeline_name,\n                inputs=pipeline_inputs\n            )\n\n            execution_time = (datetime.now() - start_time).total_seconds()\n            self._pipeline_count += 1\n\n            logger.info(\n                f\"Pipeline '{pipeline_name}' completed synchronously \"\n                f\"in {execution_time:.2f}s\"\n            )\n\n        except Exception as e:\n            logger.error(f\"Synchronous pipeline execution failed: {e}\")\n            self._error_count += 1\n            raise PipelineExecutionError(\n                f\"Synchronous execution of '{pipeline_name}' failed: {e}\"\n            ) from e\n\n    def _execute_pipeline_async(\n        self, \n        pipeline_name: str, \n        message_data: Dict[str, Any],\n        message: MQTTMessage\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Execute pipeline asynchronously via job queue.\n\n        Args:\n            pipeline_name: Name of pipeline to execute\n            message_data: Parsed message data\n            message: Original MQTT message\n\n        Returns:\n            Job ID if successful, None if failed\n        \"\"\"\n        if not self.job_queue_manager:\n            logger.error(\"Job queue not available for async execution\")\n            self._error_count += 1\n            return None\n\n        try:\n            # Enqueue pipeline execution job\n            job = self.job_queue_manager.enqueue(\n                execute_pipeline_job,\n                pipeline_name,\n                message_data,\n                self.config.base_dir,\n                message.topic,\n                message.qos,\n                {\"execution_mode\": \"async\"}\n            )\n\n            job_id = job.id if hasattr(job, 'id') else str(job)\n            self._pipeline_count += 1\n\n            logger.info(\n                f\"Pipeline '{pipeline_name}' queued for async execution \"\n                f\"(job ID: {job_id})\"\n            )\n\n            return job_id\n\n        except Exception as e:\n            logger.error(f\"Async pipeline execution failed: {e}\")\n            self._error_count += 1\n            return None\n\n    async def start_listener(self, background: bool = False) -&gt; None:\n        \"\"\"\n        Start MQTT message listener.\n\n        Args:\n            background: If True, run listener in background task\n        \"\"\"\n        if self._running:\n            logger.warning(\"Listener already running\")\n            return\n\n        self._running = True\n        self._start_time = datetime.now()\n\n        logger.info(f\"Starting MQTT listener (background={background})\")\n\n        if background:\n            self._listener_task = asyncio.create_task(self._listen_loop())\n        else:\n            await self._listen_loop()\n\n    async def _listen_loop(self) -&gt; None:\n        \"\"\"Main listening loop.\"\"\"\n        try:\n            # Set up signal handlers for graceful shutdown\n            if not asyncio.current_task().cancelled():\n                loop = asyncio.get_event_loop()\n                for sig in [signal.SIGINT, signal.SIGTERM]:\n                    try:\n                        loop.add_signal_handler(sig, self._signal_handler)\n                    except NotImplementedError:\n                        # Windows doesn't support signal handlers\n                        pass\n\n            # Start listening for messages\n            await self.mqtt_client.listen_for_messages()\n\n        except asyncio.CancelledError:\n            logger.info(\"Listener loop cancelled\")\n        except Exception as e:\n            logger.error(f\"Error in listener loop: {e}\")\n            raise\n        finally:\n            self._running = False\n\n    def _signal_handler(self) -&gt; None:\n        \"\"\"Handle shutdown signals.\"\"\"\n        logger.info(\"Received shutdown signal\")\n        self._shutdown_event.set()\n        if self._listener_task:\n            self._listener_task.cancel()\n\n    async def stop_listener(self, timeout: float = 10.0) -&gt; None:\n        \"\"\"\n        Stop MQTT message listener.\n\n        Args:\n            timeout: Maximum time to wait for graceful shutdown\n        \"\"\"\n        if not self._running:\n            logger.warning(\"Listener not running\")\n            return\n\n        logger.info(\"Stopping MQTT listener\")\n\n        # Signal shutdown\n        self._shutdown_event.set()\n\n        # Cancel listener task if running in background\n        if self._listener_task:\n            self._listener_task.cancel()\n\n            try:\n                await asyncio.wait_for(self._listener_task, timeout=timeout)\n            except (asyncio.TimeoutError, asyncio.CancelledError):\n                logger.warning(\"Listener task did not stop gracefully\")\n\n        self._running = False\n        logger.info(\"MQTT listener stopped\")\n\n    def get_statistics(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get listener statistics.\n\n        Returns:\n            Dictionary with current statistics\n        \"\"\"\n        runtime = None\n        if self._start_time:\n            runtime = (datetime.now() - self._start_time).total_seconds()\n\n        stats = {\n            \"running\": self._running,\n            \"start_time\": self._start_time.isoformat() if self._start_time else None,\n            \"runtime_seconds\": runtime,\n            \"message_count\": self._message_count,\n            \"pipeline_count\": self._pipeline_count,\n            \"error_count\": self._error_count,\n            \"subscriptions\": len(self.mqtt_client.get_all_subscriptions()),\n            \"job_queue_enabled\": self.config.job_queue.enabled\n        }\n\n        # Add job queue stats if available\n        if self.job_queue_manager:\n            try:\n                # This would depend on the JobQueueManager implementation\n                stats[\"job_queue_stats\"] = {\n                    \"queue_name\": self.config.job_queue.queue_name,\n                    \"type\": self.config.job_queue.type\n                }\n            except Exception as e:\n                logger.debug(f\"Could not get job queue stats: {e}\")\n\n        return stats\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if listener is running.\"\"\"\n        return self._running\n</code></pre> Attributes\u00b6 is_running <code>property</code> \u00b6 <pre><code>is_running: bool\n</code></pre> <p>Check if listener is running.</p> Functions\u00b6 __init__ \u00b6 <pre><code>__init__(mqtt_client: MQTTClient, config: FlowerPowerMQTTConfig)\n</code></pre> <p>Initialize MQTT listener.</p> <p>Parameters:</p> Name Type Description Default <code>mqtt_client</code> <code>MQTTClient</code> <p>Connected MQTT client instance</p> required <code>config</code> <code>FlowerPowerMQTTConfig</code> <p>FlowerPower MQTT configuration</p> required Source code in <code>src/flowerpower_mqtt/listener.py</code> <pre><code>def __init__(\n    self, \n    mqtt_client: MQTTClient,\n    config: FlowerPowerMQTTConfig\n):\n    \"\"\"\n    Initialize MQTT listener.\n\n    Args:\n        mqtt_client: Connected MQTT client instance\n        config: FlowerPower MQTT configuration\n    \"\"\"\n    self.mqtt_client = mqtt_client\n    self.config = config\n\n    # FlowerPower managers\n    self.pipeline_manager = PipelineManager(base_dir=config.base_dir)\n    self.job_queue_manager: Optional[JobQueueManager] = None\n\n    # State management\n    self._running = False\n    self._listener_task: Optional[asyncio.Task] = None\n    self._shutdown_event = asyncio.Event()\n\n    # Statistics\n    self._message_count = 0\n    self._pipeline_count = 0\n    self._error_count = 0\n    self._start_time: Optional[datetime] = None\n\n    # Initialize job queue if enabled\n    if config.job_queue.enabled:\n        self._init_job_queue()\n\n    # Register message handler\n    self.mqtt_client.add_message_handler(self._handle_message)\n</code></pre> start_listener <code>async</code> \u00b6 <pre><code>start_listener(background: bool = False) -&gt; None\n</code></pre> <p>Start MQTT message listener.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>bool</code> <p>If True, run listener in background task</p> <code>False</code> Source code in <code>src/flowerpower_mqtt/listener.py</code> <pre><code>async def start_listener(self, background: bool = False) -&gt; None:\n    \"\"\"\n    Start MQTT message listener.\n\n    Args:\n        background: If True, run listener in background task\n    \"\"\"\n    if self._running:\n        logger.warning(\"Listener already running\")\n        return\n\n    self._running = True\n    self._start_time = datetime.now()\n\n    logger.info(f\"Starting MQTT listener (background={background})\")\n\n    if background:\n        self._listener_task = asyncio.create_task(self._listen_loop())\n    else:\n        await self._listen_loop()\n</code></pre> stop_listener <code>async</code> \u00b6 <pre><code>stop_listener(timeout: float = 10.0) -&gt; None\n</code></pre> <p>Stop MQTT message listener.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time to wait for graceful shutdown</p> <code>10.0</code> Source code in <code>src/flowerpower_mqtt/listener.py</code> <pre><code>async def stop_listener(self, timeout: float = 10.0) -&gt; None:\n    \"\"\"\n    Stop MQTT message listener.\n\n    Args:\n        timeout: Maximum time to wait for graceful shutdown\n    \"\"\"\n    if not self._running:\n        logger.warning(\"Listener not running\")\n        return\n\n    logger.info(\"Stopping MQTT listener\")\n\n    # Signal shutdown\n    self._shutdown_event.set()\n\n    # Cancel listener task if running in background\n    if self._listener_task:\n        self._listener_task.cancel()\n\n        try:\n            await asyncio.wait_for(self._listener_task, timeout=timeout)\n        except (asyncio.TimeoutError, asyncio.CancelledError):\n            logger.warning(\"Listener task did not stop gracefully\")\n\n    self._running = False\n    logger.info(\"MQTT listener stopped\")\n</code></pre> get_statistics \u00b6 <pre><code>get_statistics() -&gt; Dict[str, Any]\n</code></pre> <p>Get listener statistics.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with current statistics</p> Source code in <code>src/flowerpower_mqtt/listener.py</code> <pre><code>def get_statistics(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get listener statistics.\n\n    Returns:\n        Dictionary with current statistics\n    \"\"\"\n    runtime = None\n    if self._start_time:\n        runtime = (datetime.now() - self._start_time).total_seconds()\n\n    stats = {\n        \"running\": self._running,\n        \"start_time\": self._start_time.isoformat() if self._start_time else None,\n        \"runtime_seconds\": runtime,\n        \"message_count\": self._message_count,\n        \"pipeline_count\": self._pipeline_count,\n        \"error_count\": self._error_count,\n        \"subscriptions\": len(self.mqtt_client.get_all_subscriptions()),\n        \"job_queue_enabled\": self.config.job_queue.enabled\n    }\n\n    # Add job queue stats if available\n    if self.job_queue_manager:\n        try:\n            # This would depend on the JobQueueManager implementation\n            stats[\"job_queue_stats\"] = {\n                \"queue_name\": self.config.job_queue.queue_name,\n                \"type\": self.config.job_queue.type\n            }\n        except Exception as e:\n            logger.debug(f\"Could not get job queue stats: {e}\")\n\n    return stats\n</code></pre>"},{"location":"api/#flowerpower_mqtt.listener-functions","title":"Functions","text":""},{"location":"programmatic-usage/","title":"Programmatic Usage","text":"<p>The <code>flowerpower-mqtt</code> library provides a powerful and flexible Python API for integrating MQTT message processing directly into your applications. This section details how to use the <code>MQTTPlugin</code> class and its associated methods to connect to MQTT brokers, manage subscriptions, and configure pipeline execution.</p>"},{"location":"programmatic-usage/#overview-of-the-mqttplugin","title":"Overview of the <code>MQTTPlugin</code>","text":"<p>The <code>MQTTPlugin</code> class is the primary entry point for programmatic interaction. It allows you to:</p> <ul> <li>Establish and manage connections to MQTT brokers.</li> <li>Subscribe and unsubscribe from MQTT topics.</li> <li>Link incoming MQTT messages to FlowerPower pipelines.</li> <li>Control the execution mode (synchronous, asynchronous, or mixed) of pipelines.</li> <li>Load configurations from YAML files or define them directly in code.</li> <li>Access real-time statistics and monitoring data.</li> </ul>"},{"location":"programmatic-usage/#key-classes-and-concepts","title":"Key Classes and Concepts","text":"<p>Before diving into the specifics, it's helpful to understand the main components you'll interact with:</p> <ul> <li><code>MQTTPlugin</code>: The main class for managing MQTT connections and pipeline execution.</li> <li><code>MQTTConfig</code>: Defines the MQTT broker connection parameters.</li> <li><code>JobQueueConfig</code>: Configures the optional RQ job queue for asynchronous processing.</li> <li><code>SubscriptionConfig</code>: Represents a single MQTT topic subscription and its associated FlowerPower pipeline.</li> <li><code>FlowerPowerMQTTConfig</code>: The overarching configuration object that combines MQTT, job queue, and subscription settings.</li> </ul>"},{"location":"programmatic-usage/#asynchronous-nature","title":"Asynchronous Nature","text":"<p><code>flowerpower-mqtt</code> is built on <code>asyncio</code>, Python's framework for writing concurrent code. This means most of its core operations (connecting, subscribing, listening) are <code>awaitable</code> coroutines. When using the programmatic API, you'll typically run these operations within an <code>asyncio</code> event loop.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def my_application():\n    # Your MQTTPlugin logic here\n    pass\n\nif __name__ == \"__main__\":\n    asyncio.run(my_application())\n</code></pre> <p>This asynchronous design ensures that your application remains responsive while waiting for network I/O (like MQTT messages) and allows for efficient handling of multiple concurrent operations.</p>"},{"location":"programmatic-usage/configuration/","title":"Configuration","text":"<p><code>flowerpower-mqtt</code> offers robust configuration management, allowing you to define MQTT connection parameters, job queue settings, and topic subscriptions using YAML files. This promotes consistency, reusability, and version control of your application settings.</p>"},{"location":"programmatic-usage/configuration/#loading-configuration-from-a-file","title":"Loading Configuration from a File","text":"<p>The recommended way to load configuration is from a YAML file using the <code>MQTTPlugin.from_config()</code> class method.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Load configuration from a YAML file\n    mqtt = MQTTPlugin.from_config(\"my_mqtt_config.yml\")\n\n    await mqtt.connect()\n    await mqtt.start_listener()\n    # ...\n    await mqtt.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Parameters:</p> <ul> <li><code>config_path</code> (<code>Union[str, Path]</code>): The path to your YAML configuration file.</li> </ul>"},{"location":"programmatic-usage/configuration/#configuration-structure","title":"Configuration Structure","text":"<p>The configuration is structured hierarchically, with top-level keys for <code>mqtt</code>, <code>job_queue</code>, <code>subscriptions</code>, <code>base_dir</code>, and <code>log_level</code>.</p> <pre><code># my_mqtt_config.yml\nmqtt:\n  broker: \"mqtt.example.com\"\n  port: 1883\n  keepalive: 60\n  client_id: \"flowerpower_mqtt_client\"\n  reconnect_retries: 5\n  reconnect_delay: 5\n  username: \"optional_username\"\n  password: \"optional_password\"\n\nsubscriptions:\n  - topic: \"sensors/+/temperature\"\n    pipeline: \"temperature_processor\"\n    qos: 1\n    execution_mode: \"async\"\n  - topic: \"alerts/critical\"\n    pipeline: \"alert_handler\"\n    qos: 2\n    execution_mode: \"sync\"\n\njob_queue:\n  enabled: true\n  type: \"rq\" # Currently only \"rq\" is supported\n  redis_url: \"redis://localhost:6379/0\"\n  queue_name: \"mqtt_pipelines\"\n  worker_count: 4\n  max_retries: 3 # Max retries for failed jobs\n\nbase_dir: \"/path/to/your/flowerpower/project\" # Absolute or relative path\nlog_level: \"INFO\" # DEBUG, INFO, WARNING, ERROR, CRITICAL\n</code></pre>"},{"location":"programmatic-usage/configuration/#configuration-sections","title":"Configuration Sections:","text":"<ul> <li><code>mqtt</code>: Defines parameters for the MQTT broker connection.<ul> <li><code>broker</code> (<code>str</code>): MQTT broker hostname or IP.</li> <li><code>port</code> (<code>int</code>): Broker port.</li> <li><code>keepalive</code> (<code>int</code>): Maximum period in seconds between messages sent or received.</li> <li><code>client_id</code> (<code>str</code>, optional): MQTT client ID. If not provided, a random one is generated.</li> <li><code>clean_session</code> (<code>bool</code>): Set to <code>True</code> for a clean session (no persistent session state).</li> <li><code>username</code> (<code>str</code>, optional): Username for authentication.</li> <li><code>password</code> (<code>str</code>, optional): Password for authentication.</li> <li><code>reconnect_retries</code> (<code>int</code>): Number of times to attempt reconnection.</li> <li><code>reconnect_delay</code> (<code>int</code>): Base delay in seconds for exponential backoff during reconnection.</li> </ul> </li> <li><code>subscriptions</code>: A list of individual subscription configurations. Each item in the list is a dictionary with:<ul> <li><code>topic</code> (<code>str</code>): MQTT topic pattern.</li> <li><code>pipeline</code> (<code>str</code>): Name of the FlowerPower pipeline.</li> <li><code>qos</code> (<code>int</code>, optional): QoS level (0, 1, or 2).</li> <li><code>execution_mode</code> (<code>str</code>, optional): Pipeline execution mode (<code>sync</code>, <code>async</code>, <code>mixed</code>).</li> </ul> </li> <li><code>job_queue</code>: Configures the optional job queue for asynchronous processing.<ul> <li><code>enabled</code> (<code>bool</code>): Set to <code>true</code> to enable job queue.</li> <li><code>type</code> (<code>str</code>): Type of job queue (currently only <code>\"rq\"</code> is supported).</li> <li><code>redis_url</code> (<code>str</code>): Redis connection URL (e.g., <code>redis://localhost:6379/0</code>).</li> <li><code>queue_name</code> (<code>str</code>): Name of the Redis queue.</li> <li><code>worker_count</code> (<code>int</code>): Recommended number of RQ workers.</li> <li><code>max_retries</code> (<code>int</code>): Maximum number of times a failed job will be retried.</li> </ul> </li> <li><code>base_dir</code> (<code>str</code>): The base directory of your FlowerPower project. This is essential for <code>flowerpower-mqtt</code> to find and execute your pipelines.</li> <li><code>log_level</code> (<code>str</code>): The logging level for the plugin (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>).</li> </ul>"},{"location":"programmatic-usage/configuration/#saving-current-configuration","title":"Saving Current Configuration","text":"<p>You can save the plugin's current configuration (including any subscriptions added programmatically) to a YAML file using the <code>save_config()</code> method.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    mqtt = MQTTPlugin(broker=\"localhost\", base_dir=\".\")\n    await mqtt.connect()\n    await mqtt.subscribe(\"new/data\", \"new_pipeline\")\n\n    # Save the current configuration to a file\n    mqtt.save_config(\"updated_mqtt_config.yml\")\n\n    await mqtt.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Parameters:</p> <ul> <li><code>file_path</code> (<code>Union[str, Path]</code>): The path where the configuration will be saved.</li> </ul>"},{"location":"programmatic-usage/configuration/#flowerpowermqttconfig-class","title":"<code>FlowerPowerMQTTConfig</code> Class","text":"<p>For advanced use cases, you can directly interact with the <code>FlowerPowerMQTTConfig</code> class, which is a <code>msgspec.Struct</code>. This allows for programmatic construction and manipulation of the configuration object.</p> <pre><code>from flowerpower_mqtt.config import FlowerPowerMQTTConfig, MQTTConfig, SubscriptionConfig, JobQueueConfig\n\n# Create configuration objects programmatically\nmqtt_conf = MQTTConfig(broker=\"test.mosquitto.org\", port=1883)\njob_queue_conf = JobQueueConfig(enabled=True, redis_url=\"redis://my_redis:6379\")\nsub_conf = SubscriptionConfig(topic=\"my/topic\", pipeline=\"my_pipeline\", qos=1)\n\nfull_config = FlowerPowerMQTTConfig(\n    mqtt=mqtt_conf,\n    job_queue=job_queue_conf,\n    subscriptions=[sub_conf],\n    base_dir=\"/app/pipelines\",\n    log_level=\"DEBUG\"\n)\n\n# You can then pass this object to the MQTTPlugin constructor\nplugin = MQTTPlugin(config=full_config)\n\n# Or convert it to a dictionary or YAML\nconfig_dict = full_config.to_dict()\n# full_config.to_yaml(\"programmatic_config.yml\")\n</code></pre>"},{"location":"programmatic-usage/mqtt-plugin/","title":"MQTT Plugin","text":"<p>The <code>MQTTPlugin</code> class is the core of the <code>flowerpower-mqtt</code> programmatic API. It provides all the necessary methods to interact with an MQTT broker, manage subscriptions, and integrate with FlowerPower pipelines.</p>"},{"location":"programmatic-usage/mqtt-plugin/#initialization","title":"Initialization","text":"<p>You can initialize the <code>MQTTPlugin</code> in two primary ways:</p>"},{"location":"programmatic-usage/mqtt-plugin/#1-direct-initialization","title":"1. Direct Initialization","text":"<p>Initialize the plugin by passing connection parameters directly. This is useful for simple setups or when your configuration is dynamic.</p> <pre><code>from flowerpower_mqtt import MQTTPlugin\n\n# Basic initialization\nmqtt = MQTTPlugin(\n    broker=\"localhost\",\n    port=1883,\n    base_dir=\"/path/to/your/flowerpower/project\"\n)\n\n# With job queue enabled\nmqtt_with_rq = MQTTPlugin(\n    broker=\"mqtt.example.com\",\n    base_dir=\"/path/to/your/flowerpower/project\",\n    use_job_queue=True,\n    redis_url=\"redis://localhost:6379\"\n)\n\n# With additional MQTT client options\nmqtt_custom = MQTTPlugin(\n    broker=\"broker.hivemq.com\",\n    client_id=\"my_custom_client\",\n    username=\"myuser\",\n    password=\"mypassword\",\n    reconnect_retries=10,\n    base_dir=\"/path/to/your/flowerpower/project\"\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>broker</code> (<code>str</code>, optional): The hostname or IP address of the MQTT broker. Defaults to <code>\"localhost\"</code>.</li> <li><code>port</code> (<code>int</code>, optional): The port of the MQTT broker. Defaults to <code>1883</code>.</li> <li><code>base_dir</code> (<code>str</code>): The base directory of your FlowerPower project. This is crucial for <code>flowerpower-mqtt</code> to locate and execute your pipelines.</li> <li><code>use_job_queue</code> (<code>bool</code>, optional): Set to <code>True</code> to enable asynchronous pipeline execution via RQ job queue. Defaults to <code>False</code>.</li> <li><code>redis_url</code> (<code>str</code>, optional): The Redis connection URL if <code>use_job_queue</code> is <code>True</code>. Defaults to <code>\"redis://localhost:6379\"</code>.</li> <li><code>config</code> (<code>FlowerPowerMQTTConfig</code>, optional): A complete configuration object. If provided, it overrides all other direct parameters.</li> <li><code>**mqtt_kwargs</code>: Additional keyword arguments are passed directly to the underlying <code>aiomqtt.Client</code> for advanced MQTT client configuration (e.g., <code>client_id</code>, <code>username</code>, <code>password</code>, <code>keepalive</code>, <code>clean_session</code>, <code>reconnect_retries</code>, <code>reconnect_delay</code>).</li> </ul>"},{"location":"programmatic-usage/mqtt-plugin/#2-initialization-from-configuration-file","title":"2. Initialization from Configuration File","text":"<p>Load the plugin's configuration from a YAML file. This is the recommended approach for production deployments and complex setups, as it allows for easy version control and management of your settings.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    # Load from a YAML configuration file\n    mqtt = MQTTPlugin.from_config(\"mqtt_config.yml\")\n\n    await mqtt.connect()\n    # ...\n    await mqtt.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Parameters:</p> <ul> <li><code>config_path</code> (<code>Union[str, Path]</code>): The path to your YAML configuration file.</li> </ul>"},{"location":"programmatic-usage/mqtt-plugin/#connection-management","title":"Connection Management","text":""},{"location":"programmatic-usage/mqtt-plugin/#connect","title":"<code>connect()</code>","text":"<p>Asynchronously connects the plugin to the configured MQTT broker. This method must be called before subscribing to topics or starting the listener.</p> <pre><code>await mqtt.connect()\n</code></pre>"},{"location":"programmatic-usage/mqtt-plugin/#disconnect","title":"<code>disconnect()</code>","text":"<p>Asynchronously disconnects the plugin from the MQTT broker. It also stops the listener if it's running.</p> <pre><code>await mqtt.disconnect()\n</code></pre>"},{"location":"programmatic-usage/mqtt-plugin/#context-manager-usage","title":"Context Manager Usage","text":"<p>The <code>MQTTPlugin</code> can be used as an asynchronous context manager, ensuring that the connection is properly established and closed, even if errors occur. This is the recommended way to manage the plugin's lifecycle in <code>asyncio</code> applications.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def run_mqtt_application():\n    async with MQTTPlugin(broker=\"localhost\", base_dir=\".\") as mqtt:\n        # Connection is established here\n        await mqtt.subscribe(\"sensor/data\", \"process_sensor_data\")\n        await mqtt.start_listener()\n    # Connection is automatically disconnected when exiting the 'async with' block\n</code></pre>"},{"location":"programmatic-usage/mqtt-plugin/#properties","title":"Properties","text":"<ul> <li><code>is_connected</code> (<code>bool</code>): Returns <code>True</code> if the plugin is currently connected to the MQTT broker, <code>False</code> otherwise.</li> <li><code>is_listening</code> (<code>bool</code>): Returns <code>True</code> if the MQTT message listener is currently running, <code>False</code> otherwise.</li> </ul>"},{"location":"programmatic-usage/subscriptions/","title":"Subscriptions","text":"<p>Managing MQTT subscriptions is a core function of <code>flowerpower-mqtt</code>. This section details how to programmatically subscribe to topics, specify Quality of Service (QoS) levels, define execution modes for pipelines, and retrieve current subscription information.</p>"},{"location":"programmatic-usage/subscriptions/#subscribing-to-topics","title":"Subscribing to Topics","text":"<p>The <code>subscribe()</code> method allows you to link an MQTT topic pattern to a FlowerPower pipeline.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def setup_subscriptions(mqtt: MQTTPlugin):\n    # Subscribe to a single topic with default QoS 0 and sync execution\n    await mqtt.subscribe(\"sensor/temperature\", \"process_temperature\")\n\n    # Subscribe with QoS 1 and asynchronous execution\n    await mqtt.subscribe(\"data/logs\", \"store_logs\", qos=1, execution_mode=\"async\")\n\n    # Subscribe with QoS 2 and mixed execution mode\n    await mqtt.subscribe(\"critical/alerts\", \"handle_alert\", qos=2, execution_mode=\"mixed\")\n\nasync def main():\n    async with MQTTPlugin(broker=\"localhost\", base_dir=\".\") as mqtt:\n        await setup_subscriptions(mqtt)\n        await mqtt.start_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Parameters:</p> <ul> <li><code>topic</code> (<code>str</code>): The MQTT topic pattern to subscribe to. This can include wildcards (<code>+</code> for single-level, <code>#</code> for multi-level).</li> <li><code>pipeline_name</code> (<code>str</code>): The name of the FlowerPower pipeline to execute when a message arrives on this topic.</li> <li><code>qos</code> (<code>int</code>, optional): The Quality of Service level for the subscription. Must be 0, 1, or 2. Defaults to 0.<ul> <li>0 (At most once): Messages are delivered at most once, or they may not be delivered at all. No acknowledgment is sent by the receiver, and no retransmission is performed by the sender.</li> <li>1 (At least once): Messages are guaranteed to arrive at least once. The receiver sends an acknowledgment (PUBACK), and the sender retransmits if no PUBACK is received within a certain time. Duplicate messages are possible.</li> <li>2 (Exactly once): Messages are guaranteed to arrive exactly once. This involves a four-way handshake between sender and receiver to ensure no duplication and guaranteed delivery.</li> </ul> </li> <li><code>execution_mode</code> (<code>str</code>, optional): The execution mode for the linked pipeline. Must be <code>\"sync\"</code>, <code>\"async\"</code>, or <code>\"mixed\"</code>. Defaults to <code>\"sync\"</code>. See Core Concepts - Execution Modes for details.</li> </ul> <p>Exceptions:</p> <ul> <li><code>ConnectionError</code>: If the plugin is not connected to the MQTT broker.</li> <li><code>SubscriptionError</code>: If an invalid QoS level or execution mode is provided.</li> </ul>"},{"location":"programmatic-usage/subscriptions/#bulk-subscriptions","title":"Bulk Subscriptions","text":"<p>For convenience, you can subscribe to multiple topics at once using the <code>subscribe_bulk()</code> method. This method takes a list of dictionaries, where each dictionary represents a subscription with the same parameters as the <code>subscribe()</code> method.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def setup_bulk_subscriptions(mqtt: MQTTPlugin):\n    subscriptions_list = [\n        {\"topic\": \"sensors/+/temperature\", \"pipeline\": \"temp_monitor\", \"qos\": 1, \"execution_mode\": \"async\"},\n        {\"topic\": \"alerts/critical/#\", \"pipeline\": \"alert_handler\", \"qos\": 2, \"execution_mode\": \"sync\"},\n        {\"topic\": \"data/batch/+\", \"pipeline\": \"batch_processor\", \"qos\": 0, \"execution_mode\": \"async\"}\n    ]\n    await mqtt.subscribe_bulk(subscriptions_list)\n\nasync def main():\n    async with MQTTPlugin(broker=\"localhost\", base_dir=\".\") as mqtt:\n        await setup_bulk_subscriptions(mqtt)\n        await mqtt.start_listener()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Parameters:</p> <ul> <li><code>subscriptions</code> (<code>List[Dict[str, Any]]</code>): A list of dictionaries, each containing <code>topic</code>, <code>pipeline</code>, <code>qos</code> (optional), and <code>execution_mode</code> (optional) keys.</li> </ul>"},{"location":"programmatic-usage/subscriptions/#unsubscribing-from-topics","title":"Unsubscribing from Topics","text":"<p>The <code>unsubscribe()</code> method allows you to remove an existing subscription.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    async with MQTTPlugin(broker=\"localhost\", base_dir=\".\") as mqtt:\n        await mqtt.subscribe(\"test/topic\", \"test_pipeline\")\n        # ... later ...\n        await mqtt.unsubscribe(\"test/topic\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Parameters:</p> <ul> <li><code>topic</code> (<code>str</code>): The exact MQTT topic pattern that was previously subscribed to.</li> </ul> <p>Exceptions:</p> <ul> <li><code>ConnectionError</code>: If the plugin is not connected to the MQTT broker.</li> </ul>"},{"location":"programmatic-usage/subscriptions/#listing-subscriptions","title":"Listing Subscriptions","text":"<p>You can retrieve a list of all currently active subscriptions using the <code>get_subscriptions()</code> method. This returns a list of dictionaries, each containing details about a subscription, including runtime statistics like message counts.</p> <pre><code>import asyncio\nfrom flowerpower_mqtt import MQTTPlugin\n\nasync def main():\n    async with MQTTPlugin(broker=\"localhost\", base_dir=\".\") as mqtt:\n        await mqtt.subscribe(\"sensors/temp\", \"temp_pipeline\")\n        await mqtt.subscribe(\"sensors/hum\", \"hum_pipeline\")\n\n        # Get current subscriptions\n        subscriptions = mqtt.get_subscriptions()\n        for sub in subscriptions:\n            print(f\"Topic: {sub['topic']}, Pipeline: {sub['pipeline']}, Messages: {sub.get('message_count', 0)}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Returns:</p> <ul> <li><code>List[Dict[str, Any]]</code>: A list of dictionaries, where each dictionary contains:<ul> <li><code>topic</code> (<code>str</code>): The subscribed topic pattern.</li> <li><code>pipeline</code> (<code>str</code>): The name of the associated FlowerPower pipeline.</li> <li><code>qos</code> (<code>int</code>): The QoS level of the subscription.</li> <li><code>execution_mode</code> (<code>str</code>): The execution mode for the pipeline.</li> <li><code>message_count</code> (<code>int</code>): The number of messages received on this topic since the listener started.</li> <li><code>last_message_time</code> (<code>float</code>, optional): Timestamp of the last message received.</li> <li><code>error_count</code> (<code>int</code>): The number of errors encountered for this subscription.</li> </ul> </li> </ul>"}]}